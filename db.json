{
  "posts": [
    {
      "id": 1,
      "userId": 1,
      "title": "week1",
      "body": "交作業流程\n\n新開 branch ，例如:第一週，所以開一個叫week1的branch 指令: git branch week1.\n\n切換到剛開的 branch， 指令: git checkout week1.\n\n寫完作業後用指令 git add . 將剛剛寫好的作業加入到暫存區。\n\n使用指令: git commit 將暫存區檔案存到本地repo\n\n使用指令: git push origin week1，將本地repo的檔案推上遠端。\n\n接者到 複製的課綱頁面下，例如: mentor-program-4th-CHANG-CHING-CHUNG，點選 create pull request，提出將 week1 合併到master裡的Request，然後等審核的人確認並合併。\n\n到學習系統頁面，點選作業列表，新增作業，選擇作業週數，例: wee1，將pull request的連結頁面貼上並確認已檢查過作業及自我檢討後按送出。\n\n當作業被批改完並被 merge 後，將目前分支切換回 master ，指令: git checkout master。\n\n使用指令: git pull origin master 將遠端最新的檔案拉到本地端同步。\n\n刪除 wee1 分支，指令: git branch -d week1。\n\n教你朋友 CLI\n\nCommand-line 是什麼?\nCommand-line是一種以文字為主的應用程式，以輸入文字指令的方式操縱電腦的所有動作，例如: Windows系統下的 CMD，命令提示字元程式。\n\n使用Command-line建立資料夾及檔案\n在此以 git bash 做為示範。\n第一步: 在桌面按右鍵選擇 git bash here 打開git bash應用程式。\n第二步: 輸入指令 mkdir wifi，建立一個叫 wifi 的資料夾， mkdir 是指令，用來建立資料夾，wifi 則是資料夾名稱。\n第三步: 輸入指令 cd wifi 進入剛剛建立的wifi資料夾，cd 是用來切換目錄的指令。\n第四步: 輸入指令touch afu.js 建立一個叫做afu的 Javascript檔案， touch是用來建立空檔案及更新檔案修改時間的指令。\n第五步: 輸入 ls 檢查該目錄底下的檔案，輸入後會出現 afu.js，表示檔案建立成功。\n\n跟你朋友介紹 Git\n\nGit 的基本概念\nGit 是一個可以紀錄並追蹤檔案更動紀錄的系統，基本原理是: 建立一個主幹 Master，裡面存放原始檔案，每次檔案變動時，新建一個含有版本號的資料夾，裡面存放更改過後的檔案，並將變動紀錄起來，以便追蹤有哪些檔案被更改及什麼地方被改變。\n以下用 Git 的指令來實際演練一遍 Git 是如何運作的。\n\nGit 指令的運用\n此處我們要教導如何建立本地 Repository 以及將本地 Repository 與遠端 Repository 連結\n\n第一步-git init: 建立資料夾及檔案，開啟 git bash 並 cd 進入該資料夾底下，輸入 git init 初始化本地 Repository。\n\n第二步-git add: 初始化之後，使用 git add將檔案新增到本地 Repository 的暫存區，git add 後面加上你要加入到版本控制的檔案名稱，git add 會將檔案新增到暫存區，例如:git add app.js；如果想要全部一次新增的話，可以用 git add .。\n\n第四步-git status: 使用 git status 確認剛剛的檔案有新增進暫存區，這時會顯示， On branch master Changes to be committed: <此處為檔案名稱>。\n\n第三步-git commit: 這一步是要建立一個版本號資料庫並將上一步所新增的檔案移到該處，輸入指令 git commit -m\"輸入此次變動的訊息\"，這裡要注意，訊息一定要輸入，不能空白。\n\n第四步-git status: commit 完之後再次輸入 git status確認，此時會顯示On branch master nothing to commit, working tree clean。\n\n第五步-建立遠端 Repository: 到 github 網站上，建立一個空的 repository。\n\n第六步-git remote add origin: 在本地 repository 上輸入 git remote add origin <節點>，將本地與遠端連結在一起，例如: git remote add origin https://github.com/CHANG-CHING-CHUNG/test.git。\n\n第七步-git push: 將本地與遠端連結在一起後，使用 git push 將本地檔案上傳到遠端，例如: git push -u origin master，上傳完後，遠端頁面刷新就可看到剛剛 push 上去的檔案了。\n最後一步-git pull: 如果今天別人更動了遠端的檔案，而要跟遠端同步，輸入 git pull 將遠端的檔案同步到本地端，使自己本機的檔案永遠保持在最新，這一點在跟別人協作時非常重要，每次開始本地專案要開始作業時，最好都先 git pull 先同步過，以免衝突。\n\n請解釋後端與前端的差異。\n\n前端\n前端是視覺化的部份，例如網頁的外觀，圖表，按鈕或是 Logo 等等任何看得到的元件，可以將前端想成是一棟房子的裝潢。\n\n後端\n後端是指看不到的部份，運行主要業務邏輯的區塊，例如: Google Map，當輸入地址按下規劃路線時，\n後面看不到的部份就在運算從你目前位置到該地址需要多久及選擇路線，運算過程並不會被使用者看到。\n\n\n假設我今天去 Google 首頁搜尋框打上：JavaScript 並且按下 Enter，請說出從這一刻開始到我看到搜尋結果為止發生在背後的事情。\n\n當按下輸入時，瀏覽器會發送一個包含「JavaScript」關鍵字的 request 給 Google server，當 Google server 收到 這個 request 後，\n會解析這個 request，發現裡面包含了要搜尋的關鍵字「JavaScript」，此時 Google server 就知道你想要查跟 「JavaScript」相關的資料，\n然後Google server 就用這個關鍵字去查找資料庫，將所有包含「JavaScript」關鍵字的資料都抓出來，\n資料抓出來之後將結果response丟回給瀏覽器，最後瀏覽器再將結果渲染，使用者就會看到搜尋結果了。\n\n請列舉出 3 個「課程沒有提到」的 command line 指令並且說明功用\n\nPrompt\n用來指定想要在CMD中的文字及資訊，例如: 輸入prompt $d$s$s$t$_$g\n將會在CMD中顯示 2020/06/16 週二 12:36:57.84。\n\nShutdown\n使用此指令可指定電腦要在多少秒之後關機，或是指定電腦要在幾秒之後重開機。\n例如: shutdown -s -t 10 => 電腦在10秒鐘之後關機，shutdown -r -t 10 => 電腦在10秒鐘之後重開。\n\nRegedit\n使用此指令可開啟註冊表編輯器。\n",
      "createdAt": 1608746453293
    },
    {
      "id": 2,
      "userId": 1,
      "title": "week2",
      "body": "\nfunction isValid(arr) {\n\n  for (var i = 0; i < arr.length; i++) {\n\n    if (arr[i] <= 0) return \"invalid\";\n\n  }\n\n  for (var i = 2; i < arr.length; i++) {\n\n    if (arr[i] !== arr[i - 1] + arr[i - 2]) return \"invalid\";\n\n  }\n\n  return \"valid\";\n\n}\n\n\nisValid([3, 5, 8, 13, 22, 35]);\n\n \n執行流程\n\n    執行第 1 行，設定變數 i 是 0 ，檢查 i 是否 < arr 長度 6，是，繼續執行，開始進入第一圈迴圈\n\n    執行第 2 行，判斷 arr[i] 是否 <= 0，此處 arr[i] 是 arr[0]，arr[0] 的數字是 3，不是\n\n    第一圈迴圈結束，跑回第 1 行，i++，i 變成 1，檢查 i 是否 < arr 長度 6，是，繼續執行\n\n    執行第 2 行，判斷 arr[i] 是否 <= 0，此處 arr[i] 是 arr[1]，arr[1] 的數字是 5，不是\n\n    第二圈迴圈結束，跑回第 1 行，i++，i 變成 2，檢查 i 是否 < arr 長度 6，是，繼續執行\n\n    執行第 2 行，判斷 arr[i] 是否 <= 0，此處 arr[i] 是 arr[2]，arr[2] 的數字是 8，不是\n\n    第三圈迴圈結束，跑回第 1 行，i++，i 變成 3，檢查 i 是否 < arr 長度 6，是，繼續執行\n\n    執行第 2 行，判斷 arr[i] 是否 <= 0，此處 arr[i] 是 arr[3]，arr[3] 的數字是 13，不是\n\n    第四圈迴圈結束，跑回第 1 行，i++，i 變成 4，檢查 i 是否 < arr 長度 6，是，繼續執行\n\n    執行第 2 行，判斷 arr[i] 是否 <= 0，此處 arr[i] 是 arr[4]，arr[4] 的數字是 22，不是\n\n    第五圈迴圈結束，跑回第 1 行，i++，i 變成 5，檢查 i 是否 < arr 長度 6，是，繼續執行\n\n    執行第 2 行，判斷 arr[i] 是否 <= 0，此處 arr[i] 是 arr[5]，arr[5] 的數字是 35，不是\n\n    第六圈迴圈結束，跑回第 1 行，i++，i 變成 6，檢查 i 是否 < arr 長度 6，否，跳出迴圈\n\n    執行第 4 行，設定變數 i 是 2，檢查 i 是否 < arr 長度 6，是，繼續執行，開始進入第一圈迴圈\n\n    執行第 5 行，判斷 arr[i] 是否不等於 arr[i - 1] + arr[i - 2]，這裡 arr[i] 是 8，arr[i - 1] + arr[i - 2]是 8，否\n\n    第一圈迴圈結束，跑回第 4 行，i++，i 變成 3 檢查 i 是否 < arr 長度 6，是，繼續執行\n\n    執行第 5 行，判斷 arr[i] 是否不等於 arr[i - 1] + arr[i - 2]，這裡 arr[i] 是 13，arr[i - 1] + arr[i - 2]是 13，否\n\n    第二圈迴圈結束，跑回第 4 行，i++，i 變成 4 檢查 i 是否 < arr 長度 6，是，繼續執行\n\n    執行第 5 行，判斷 arr[i] 是否不等於 arr[i - 1] + arr[i - 2]，這裡 arr[i] 是 22，arr[i - 1] + arr[i - 2]是 21，是\n\n    回傳字串 ‘invalid’，執行完畢\n",
      "createdAt": 1608746453293
    },
    {
      "id": 3,
      "userId": 1,
      "title": "week3",
      "body": "\nhw1：好多星星\n\n必須要對迴圈夠了解，並且了解題目範例的規律，很自然就解的出來了。\n\n每一次迴圈，都加上一顆星星，然後印出。\n \nhw2：水仙花數\n\n這題第一直覺就是將數字範圍用陣列列出來，然後將每一組字串分離轉成數字再將每一位數字乘位數次方後相加，最後再跟原始數字比對就完成了。\n\n看了老師的解法之後，發現我的解法真是笨的可以T.T\n\n數學底子不好對想題目解法真是一大難關啊…\n \nhw3：判斷質數\n\n這題也是在熟悉迴圈及if判斷的使用，沒什麼難度。\n \nhw4：判斷迴文\n\n這一題之前在The Odin Project的練習裡已經做過了，所以也沒什麼困難，主要就是把字串裡的符號去掉，用迴圈把字串倒者排再跟原始字串比對是否相符。\n \nhw5：聯誼順序比大小\n\n這一題用BigInt針對輸入可能會有很大的數字的情況做處理，使全部的輸入都轉成BigInt格式之後再去判斷比大比小，知道比大比小之後就可以很容易的判斷誰贏誰輸。\n\n這一題的關鍵是學習大數的比較方法。\n",
      "createdAt": 1608746453293
    },
    {
      "id": 4,
      "userId": 1,
      "title": "week4",
      "body": "\nhw1：好多星星\n\n必須要對迴圈夠了解，並且了解題目範例的規律，很自然就解的出來了。\n\n每一次迴圈，都加上一顆星星，然後印出。\n \nhw2：水仙花數\n\n這題第一直覺就是將數字範圍用陣列列出來，然後將每一組字串分離轉成數字再將每一位數字乘位數次方後相加，最後再跟原始數字比對就完成了。\n\n看了老師的解法之後，發現我的解法真是笨的可以T.T\n\n數學底子不好對想題目解法真是一大難關啊…\n \nhw3：判斷質數\n\n這題也是在熟悉迴圈及if判斷的使用，沒什麼難度。\n \nhw4：判斷迴文\n\n這一題之前在The Odin Project的練習裡已經做過了，所以也沒什麼困難，主要就是把字串裡的符號去掉，用迴圈把字串倒者排再跟原始字串比對是否相符。\n \nhw5：聯誼順序比大小\n\n這一題用BigInt針對輸入可能會有很大的數字的情況做處理，使全部的輸入都轉成BigInt格式之後再去判斷比大比小，知道比大比小之後就可以很容易的判斷誰贏誰輸。\n\n這一題的關鍵是學習大數的比較方法。\n",
      "createdAt": 1608746453293
    },
    {
      "id": 5,
      "userId": 1,
      "title": "week5",
      "body": "\n\nAPI 就像是餐廳的菜單，上面列出了餐廳提供的餐點，客戶選擇菜單上的餐點並告知服務生，\n服務生跟客戶確認過餐點後，就回到後台向廚師傳達要製作的餐點，廚師製作完餐點後，交給服務生，服務生再將餐點送到客戶的桌上。\n上述的例子裡，客戶=Client、菜單=API、服務生=Server、廚師=處理服務的應用程式。\n\n簡單說，API 就是一種列出了可使用的服務的菜單，Client 可透過 API 獲取 Server 端提供的資源。\n請找出三個課程沒教的 HTTP status code 並簡單介紹\n\n418 - I am a teapot (資料來源: Huli blog)\n這個不是標準 HTTP 的狀態碼，由來是從 1998/4/1 愚人節的一份文件，\nRFC2324, Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)，這協定是用來泡咖啡的，\n而如果有人要用茶壺泡咖啡的話，就回 418 的狀態碼，表示我是茶壺，不要拿我來泡咖啡。\n\n451 - 因法律原因不可用\n是錯誤狀態代碼，此代碼的出現代表該網頁可能對國家安全產生危害，或該網頁可能違反著作權、隱私權、褻瀆神明或其他法律或法院命令。這個代碼源於 1953 年的反烏托邦小說<華氏 451 度>，喜說中，所有書籍都是違禁品。(我覺得有趣的部分是，褻瀆神明也算違法 XDD)\n\n423 - 當前資源被鎖定\n要存取的資源被鎖定，存取不能。\n假設你現在是個餐廳平台，需要提供 API 給別人串接並提供基本的 CRUD 功能，包括：回傳所有餐廳資料、回傳單一餐廳資料、刪除餐廳、新增餐廳、更改餐廳，你的 API 會長什麼樣子？請提供一份 API 文件。\n\n 說明 \t      Method     \tpath   \t             參數 \t                 範例\n\n回傳所有餐廳資料　　 GET /restaurants limit:限制回傳資料數量 /restaurants?limit=10\n回傳單一餐廳資料　　 GET /restaurants/:id 無 /restaurants/5\n新增餐廳 POST /restaurants name:餐廳名稱 　　無\n刪除餐廳 DELETE /restaurants/:id 無 　　　　 無\n更改餐廳 PATCH /restaurants/:id name:餐廳名稱 　無\n",
      "createdAt": 1608746453293
    },
    {
      "id": 6,
      "userId": 1,
      "title": "week6",
      "body": "\n前四週心得與解題心得\n\n    前四週心得\n\n    前四週主要在學習基本的 Javascript 語法、 CLI 、 GIT 的使用及基本的 API 串接，難度不大，因為已經有學過一點了，\n\n    覺得前四週課程影片很豐富，有很多觀念是其它教學影片沒有教的，像是程式思維的建立以及拆解問題的方法等等，另外，\n\n    解題及做完作業後的檢討也是一個很棒的點子，可以學到老師是如何解題的，也學到如何運用題目之間的關聯性來解決問題。\n\n    我不是很會寫作的人，所以就不多寫了，總之，目前為止都還蠻滿意這堂課的 :)\n\n    Lidemy HTTP Challenge 解題心得\n\n    這一個小遊戲已經在這個課程計劃開始之前，今年 2 月就已經破過了，年代久遠，心得已忘，只記得關卡設計很有趣，遊玩過程需不斷查找資料\n\n    破關，因此玩完後會學到很多關於 API 的知識，好玩!\n\n    LidemyOJ 解題心得\n\n    解題很好玩，尤其 AC 的時候，那個爽度真的破錶，不過卡的時候就蠻挫折得，比較難的題目，像 1052 ，就花了許久才解出來，一直想一直想，至少花了三到四天吧，最後還是解出來了，雖然是借助了 Google 大神的幫助~QQ\n\n    覺得幫助最大的就是藉由做題目不斷找資料及實驗的過程中學習到看懂題目、拆解題目、簡化題目、各個擊破的問題解決方法了，希望能將這個技能內化並應用到生活中的各個層面，使自己成為遇到任何困難都能解決的人。\n\n",
      "createdAt": 1608746453293
    },
    {
      "id": 7,
      "userId": 1,
      "title": "week7",
      "body": "\n請找出三個課程裡面沒提到的 HTML 標籤並一一說明作用。\n\n    <ruby>\n    這個標簽是用來附加漢字發音在其相對應的漢字旁邊時用的。例如:\n    <ruby>\n    漢 <rt> ㄏㄢˋ </rt>\n\n    會變成\n\n ㄏㄢˋ\n 漢\n\n    <map> map標簽是用在圖片上的，將圖片上的某些區塊變成可點選區塊，類似按鈕的功能， 點選後可導覽至其它頁面。 用法: map標籤裡面設定area標籤，在area標籤設定該可點選區塊的形狀，在圖片上的座標及超連結。 <map name=\"workmap\"> </map>\n    <object> 這個標籤是用來置入外部資源的，例如: 影片、音檔、html、圖片等。 用法:　 <object data=\"video.mp4\" width=\"400\" height=\"300\"></object> 上面範例為在頁面置入一個mp4影片並設定寬400高300。\n\n \n請問什麼是盒模型（box model）\n\n答:\n盒模型的意思是，html 的每個元素都是一個方塊，像盒子一樣的模型，所以被當做是盒子，我們透過對每個元素的盒模型進行操縱，使元素的大小外觀符合我們想要的樣式。\n例如: 我們可以對一個 div 元素去調整 color、width、height 及 font-size 等等，其中比較重要的一點是 “box-sizing”，盒模型的寬高預設是 content-box，意思是，寬高不含 margins、padding 及 borders，這會導致如果設了 margins 等屬性會改變設定的寬度及高度，例如 width 設 100，padding 設 10，加起來寬度會變成 120，就偏離了我們想要該元素維持的寬度，所以如今我們會將 \"box-sizing\"這個屬性改成 border-box ，使總寬高維持在我們想要的寬高值，例如，我們設 width 為 100，padding 設 10，因為設了 border-box 的關係，因此瀏覽器會自動幫我們把 padding 加進去但維持總寬度為 100，這樣當我們在設計元素的時候就不容易亂，可以很好的掌控元素的寬高。\n \n請問 display: inline, block 跟 inline-block 的差別是什麼？\n\n    inline\n    inline 元素，可設定左右的 margins 跟 padding，不可設定上下的 margins 跟 padding\n    不能設定 width 及 height\n    可以跟其它元素共存在同一行\n\n    block\n    可設定上下左右的 margins 跟 padding\n    自動斷行，一個 block 元素佔一行\n    如果沒設定 width，則自動設為 full-width\n\n    inline-block\n    同時具有 inline 及 block 的特性如:\n    可以跟其它元素共存在同一行\n    可以設定上下左右的 margins 及 padding\n    可以設定 width 及 height\n\n \n請問 position: static, relative, absolute 跟 fixed 的差別是什麼？\n\n    static\n    元素的默認值為 static，表示該元素出現在文檔的常規位置\n\n    relative\n    將元素設定相對定位，設定了 relative 的元素可藉由 top, bottom, left, right 等屬性將元素定位在相對於該元素常規位置的地方，但移動過後的元素還是佔據原始位置\n\n    absolute\n    將元素設為絕對定位，設為 absolute 屬性的元素會往上尋找父元素，以父元素為相對位置進行定位。\n    如果沒有父元素，則以整個<body>元素為父元素進行定位\n\n    fixed\n    固定定位，設為 fixed 的元素會相對魚瀏覽器來定位，可設 top, right, bottom 及 left 來定位，設了 fixed 的元素，即使畫面滾動，該元素始終還是會在同一個位置\n\n",
      "createdAt": 1608746453293
    },
    {
      "id": 8,
      "userId": 1,
      "title": "week8",
      "body": "\n什麼是 DOM？\n\nDOM 全名叫做\"文件物件模型\"(Document Object Model)，將網頁元素以樹狀結構表示，每個資料都是一個節點，而節點本身也是物件，擁有自己的屬性及方法，我們可以透過操縱 DOM 去改變元素屬性及內容。\n \n事件傳遞機制的順序是什麼；什麼是冒泡，什麼又是捕獲？\n\n事件傳遞的順序為: 先捕獲、到目標、後冒泡。\n冒泡: 事件從目標向上傳遞，往父元素傳，一直到最頂層。\n捕獲: 事件發生時，最上層的父元素捕獲到事件，並將事件往下傳至目標。\n \n什麼是 event delegation，為什麼我們需要它？\n\n事件代理(Event Delegation)，在父元素設置事件監聽器，並利用點擊元素時事件會從該元素 bubbling 向上傳遞的特性，讓我們可以做到只設置一個事件監聽器就能對子元素進行操縱，而不需要一個一個為子元素設事件監聽器。\n \nevent.preventDefault() 跟 event.stopPropagation() 差在哪裡，可以舉個範例嗎？\n\nevent.preventDefault: 是用來停止元素的預設行為用的，例如: <a link=“some.website.com”>，是一個連結按鈕，按下去就會轉到 some.website.com 這個網站，如果在這個 “a” 標籤上加上 click 事件的監聽器，然後在事件發生時執行的函式中加上 event.preventDefault() ，那麼，就會將點擊 “a” 標籤自動轉址的預設行為停掉，之後怎麼點都沒有反應了。\n\nevent.stopPropagation: 用來停止事件向上或向下傳遞，例如，父元素跟子元素都設了對同個事件的監聽器，但又不想父元素同時觸發事件時，就可以在子元素的事件監聽器裡放入這個 event.stopPropagation 方法。\n\n範例: 下面例子中，有 parent 跟 child 兩個元素，都設置了點擊觸發事件，當事件發生時會跳出一個 alert，正常情況下點擊 child 元素，將會同時觸發 child 及 parent 的事件，跳出 alert(“Parent”)及 alert(“child”)，如果我們只想要 child 觸發該事件，就要在 child 元素加上事件監聽器並加上 event.stopPropagation，像下面這樣，之後無論如何點擊 child 元素都只會跳出 child 的 alert 了!\n\n「child.addEventListener(‘click’, () => {\nevent.stopPropagation();\n})」\n\n<div id=\"parent\"onClick=‘alert(“Parent”)’>\nParent\n<div id=“child” onClick=‘alert(“child”)’>\nchild\n</div>\n</div>\n",
      "createdAt": 1608746453293
    },
    {
      "id": 9,
      "userId": 1,
      "title": "week9",
      "body": "\n什麼是 Ajax？\n\nAJAX 全名叫 Asynchronous Javascript And XML，是一種可以在背景執行，透過\n非同步的方式跟網頁伺服器交換資料並更新頁面的一種技術，使用這種技術可實現網頁的部分更新，\n而不用整個網頁整個更新，減少了不必要的動作。\n \n用 Ajax 與我們用表單送出資料的差別在哪？\n\n用表單送出資料，當得到回應的時候，會整個頁面刷新，而使用 AJAX 的話，則可以將資料存到 Javascript 裡，\n存到 Javascript 裡之後我們就可以對資料進行處理並將資料顯示在頁面上，重要的是，可以只針對要顯示的部分進行渲染更新就好\n，不用整個頁面刷新。\n \nJSONP 是什麼？\n\nJSONP 全名叫作，“JSON with padding”，是一種很久以前用來存取跨網域資料的技術，\n利用 script 標籤不受同源限制的特性，發送要求到 Server 端，Server 將資料包成 Javascript 檔回傳\n我們得到回傳資料後，再執行預先定義好的函式，至此，就成功接收到資料了。，\n \n要如何存取跨網域的 API？\n\n請 Server 端在 header 加上 “Access-Control-Allow-Origin: *”。\n \n為什麼我們在第四週時沒碰到跨網域的問題，這週卻碰到了？\n\n第四週是在 runtime 執行 Javascript，沒有跨網域的限制，而現在則是透過 Browser 執行 Javascript，\n而 Browser 本身有內建安全性檢查的功能，所以才有跨網域的限制。\n",
      "createdAt": 1608746453293
    },
    {
      "id": 10,
      "userId": 1,
      "title": "week10",
      "body": "\n六到十週心得與解題心得\n\n第九週進入後端，用 php 從後端產生頁面然後丟給前端顯示，實在是很有趣，\n不過因為是第一次接觸 php，所以對語言特性很不熟，不過我想，多寫多練應該就會習慣了吧?\n\n再來就是，第九週的留言板作業，繳交上去之後，因為有各種預留漏洞導致同學各種亂板亂玩，也是很有趣 XD，不過也從中了解到資訊安全有多重要!，很可能因為一個不小心的漏洞就導致使用者的資訊就洩露出去了呢!。\n\n解題心得\n\n    綜合能力大考驗: 破關密碼=m3nT0rPr0GRAm666，這一關綜合了剛學到的 php、query string、css 選擇器及 javascript 的 event 等技能，算是很簡單的小測驗，只要打開 developer tool 看程式碼很快就能解答了。\n\n2.r30challenge: 第十關使用的組合 iCiCiCiC，這遊戲也是很早之前就破過一次了，但當時沒有留下留言，所以又再破一次留個言，遊戲關卡設計的很巧妙，很有趣，雖然破完就忘記當初怎麼破的 XD。\n",
      "createdAt": 1608746453293
    },
    {
      "id": 11,
      "userId": 1,
      "title": "week11",
      "body": "\n請說明雜湊跟加密的差別在哪裡，為什麼密碼要雜湊過後才存入資料庫\n\n加密:\n明文->密文->明文=加密雙向的，可透過解密得到原文，因此是可逆的\n加密的方式為，產生一把密鑰，將原文及密鑰經過加密演算法的加密過後，得到的輸出就是加密後的密文，\n因此，要是密鑰太短太簡單或是沒有保管好，很容易就被解密了。\n\n湊雜:\n明文->雜湊->雜湊文=雜湊是單向的，無法被反轉解密\n無論原文長短，雜湊過後的輸出都是固定長度，不同的原文作為相同雜湊的輸入，得到相同輸出的機率極低，\n因此，很適合來保存密碼這類不需要被還原的資料，避免資料庫外洩使得任何人都可以存取到使用者的帳戶\n通常還會多加 salt，來提高安全性。\n\n為什麼密碼要雜湊過後才存入資料庫\n因為密碼必須只有使用者才能知道，除了使用者外不應該能看到使用者密碼，造成使用者資料或數據有被竄改的\n可能性；另外，也是避免資料庫被攻擊，造成使用者資料外洩後，攻擊者能隨意存取使用者帳號，例如:銀行資料庫\n外洩，要是密碼是明文的，那攻擊者就能透過得到的密碼進行轉帳，將使用者的儲金轉到自己帳戶裡。\n \ninclude、require、include_once、require_once 的差別\n\ninclude 及 include_once:\ninclude-當程式讀到這一段時，會載入引用的檔案\ninclude_once-當程式讀到這一段時，會檢查要引用的檔案是否已載入過，如果載入過就不再載入\n\nrequire 及 require_once:\nrequire -當程式讀到這一段時，會載入引用的檔案\nrequire_once-當程式讀到這一段時，會檢查要引用的檔案是否已載入過，如果載入過就不再載入\n\ninclude 跟 require 最主要的差別在於，include 找不到檔案載入時，只會觸發 Warning，而不會終止程式，\n而 require 在找不到檔案載入時，會觸發 Fatal Error 並終止程式。\n \n請說明 SQL Injection 的攻擊原理以及防範方法\n\nSQL Injection 的攻擊原理:\n在輸入字串中夾帶 SQL 指令，如果應用程式是使用字串串聯的方式組合 SQ L 指令，並忽略了字元檢查的話，那麼\n這些被夾帶進去的惡意指令就會被資料庫認為是正常的指令而執行，進而使資料庫遭到入侵或破壞。\n例如，未針對輸入的單引號字元做跳脫處理的話，就會導致單引號字元內的字串被解讀為 SQL 參數，進而被識別\n為有效的 SQL 語法。\n\n防範方法: 1.參數化查詢: 撰寫 SQL 指令時，用參數代表需要填入的數值，透過 SQL 指令預編譯後才套用參數執行的方式，\n來避免 SQL 注入。\n\n2.在單引號字元前加入跳脫字元: 透過對單引號字元前加入跳脫字元使其無法成為有效的 SQL 指令。\n \n請說明 XSS 的攻擊原理以及防範方法\n\nXSS 的攻擊原理:\n全稱為跨網站指令碼攻擊，透過瀏覽器解析 HTML 語法的特性去執行特定的程式碼以竊取 Cookie、\n非公開的網頁內容或是權限等等，例如:在頁面中插入 <script>alert(document.cookie)</script>，瀏覽器會將\n此段程式碼識別為 JavaScript 程式碼並執行，跳出一個顯示當前網站 cookie 的 alert 對話框。\n\n防範方法: 1.過濾特殊字元: 對使用者所提供的內容進行過濾，例如 PHP 的 htmlspecialchars() 函數，會將 html 的\n特殊字元重新編碼再輸出成一般字串\n\n2.使用 HTTP 標頭指令類型: 例如，header(‘Content-Type: text/javascript; charset=utf-8’);，指定將\nJavaScript 指令碼轉成文字。\n \n請說明 CSRF 的攻擊原理以及防範方法\n\nCSRF 的攻擊原理:\n利用瀏覽器會記住 cookie 及 session 資訊的方式，讓被攻擊者在不同的網域底下，不知不覺的發送夾帶了\n使用者資訊的 request 到被攻擊者登入過的網站，偽造被攻擊者的身份進行一些操作，例如，發郵件、發訊息或是\n轉帳、買商品等等。\n\n防範方法: 1.使用者方面:\n可以在每次使用完網站之後就登出，這樣攻擊者就無法利用使用者處於登入狀態這一點去偽造身份進\n行操作。\n\n2.Server 的防禦:\n\n檢查Referer:\n檢查 request 的 header 的 referer 欄位，看這個 request 是從哪個網域過來的，\n如果不是，就拒絕，但要注意的是，有些瀏覽器可能不會帶 referer，或是有些使用者\n會關閉 referer 的功能，這會導致 server 拒絕掉真的使用者發出的 request，再來是\n判斷是否合法網域的程式碼要保證沒bug，不能讓攻擊者以類似的域名成功騙過 server。\n\n加上圖形驗證碼或簡訊驗證碼:\n發送簡訊到使用者手機或E-mail信箱，以確保嘗試執行操作的人是使用者本人。\n\n加上 CSRF token:\n在 form 裡面加上一個 hidden 的欄位，叫做 csrftoken，值由 server 隨機產生，並且存在 server 的\n的 session 中，使用者 submit 之後， server 比對表單中的 csrftoken 是否跟自己 session 中的 token一致\n是的話就確認這個 request 是由本人發的。\n\nDouble Submit Cookie:\n透過由 server 產生一組隨機的 token 並加在 form 上面，然後在 client side 設一個叫 csrftoken 的 cookie ，\n值則是跟 server 產生的同一組，只要client side發送的 request 裡的 cookie domain及 token 是不同的，就拒絕。\n\nclient side 的 Double Submit Cookie:\n基本上跟上面的 Double Submit Cookie 差不多，差在 token 是由 client 端生成的，核心概念為，攻擊者沒辦法讀寫目標\n網站的 cookie 所以 request 的 csrf token 會跟 cookie 內的不一樣。\n\nbrowser 本身的防禦-SameSite cookie:\n透過在設定 cookie 的時候 帶上 SameSite 這個關鍵字，代表這 cookie 只允許 same site 使用，任何 cross site\nrequest 都不會被加上這 cookie，也就是說，在 default 的 strict，加上去之後，<a href=\"\">, <form>, newXMLHttpRequest，只要被瀏覽器\n驗證後不是在同一個 site 所發出的 request 的話，就都不會帶上這 cookie，透過這種方式，不同 domain 所發出的 request 將不會帶上有者登入\n資訊的 cookie 進而達到防禦目的。\n",
      "createdAt": 1608746453293
    },
    {
      "id": 12,
      "userId": 1,
      "title": "week12",
      "body": "\n請簡單解釋什麼是 Single Page Application\n\nSPA(單頁面應用程式)，簡單來說就是個載入單一 HTML 頁面及所有執行這個應用程式所需的檔案，如 JavaScript 及 CSS 等的 web 應用程式。\n\nSPA 使用 AJAX 非同步請求去獲取資料，在資料回來後僅更新部份頁面，而不是發送請求到 Server， Server 再回傳新的頁面。\n \nSPA 的優缺點為何\n\n優點:\n\n    載入更快: SPA 只更新需要被更新的區塊內容，減少了頁面載入所需時間及使用者等待時間。\n\n    使用者更佳的體驗: SPA 透過網頁互動效果提供給那些已經習慣滾動瀏覽的行動裝置使用者非常棒的使用者體驗，所有操作只要在同一頁面即可完成。\n\n    緩存: SPA 發送請求至 Server 儲存所有接收到的資料，然後就可以使用這些資料而不用再次發送請求至 Server 要資料，所以一但接收到資料後，即使沒網路也可以進行操作。\n\n缺點:\n\n    無瀏覽器歷史: SPA 只更新部分頁面，所以在瀏覽 SPA 頁面時，不會有任何的瀏覽歷史紀錄，\n\n    SEO 優化: SEO 依賴於 URL、 Meta tags、頁面 SESSIONS、內容及網頁爬蟲，而 SPA 單頁面應用程式則是靠 JavaScript 執行及透過客戶端發送請求下載資料，在客戶端未進行操作及 JavaScript 未執行前，頁面是不會有任何資料的，因此，對於爬蟲及搜尋引擎來說，此類型網站很難被搜尋到，並且此類型網站較難進行 SEO 優化。\n\n    依賴 JavaScript: SPA 需要 JavaScript 才能運行，因此要是使用者停用 JavaScript ， SPA 將不能夠正常執行。\n\n \n這週這種後端負責提供只輸出資料的 API，前端一律都用 Ajax 串接的寫法，跟之前透過 PHP 直接輸出內容的留言板有什麼不同？\n\n透過 AJAX 串 API 的寫法，網頁不用重新載入整個渲染一遍，而直接用 PHP 直接輸出內容的寫法，則必須得整個頁面重新載入，另外，串 API 的寫法， Server 只需要傳送資料給客戶端，客戶端收到資料後再進行處理，對 Server 的負擔較小，而直接用 PHP 後端輸出內容的話，撈資料及處理資料都在 Server 端進行，對 Server 的負擔較大。\n",
      "createdAt": 1608746453293
    },
    {
      "id": 13,
      "userId": 1,
      "title": "week13",
      "body": "\nWebpack 是做什麼用的？可以不用它嗎？\n\n    Webpack 做什麼用的?\n    Webpack 是一個用來將包括 JavaScript 、 圖片、字型及 CSS 等資源打包的工具，\n    Webpack 可以讓我們在原始的 JS 檔案裡面使用原本在瀏覽器不能使用的 require\n    去指向本地檔案，例如圖片，然後決定要如何在最後的 JS bundle 中處理這圖片。\n\n    可以不用它嗎?\n    如果你正在做的應用程式或專案很小，也沒有很多靜態資源需要載入，那麼就沒必要用 Webpack。\n\n    如果你正在做的是大型專案或應用程式，包含了很多靜態資源，例如圖片、 CSS 檔、 字型檔等等，那麼使用\n    Webpack 會是一個好選擇。\n\n \ngulp 跟 webpack 有什麼不一樣？\n\ngulp 是任務執行器，用來自動化一些重複性的任務，例如編譯 SCSS、優化圖片、重整瀏覽器頁面等等，每一項任務都是獨立的，互相不干涉，只要能寫在 gulp 裡面的任務是可執行且有效的，都能夠自動化執行。\n\n而 Webpack 是前端打包工作，目的是用來將各種資態資源引入，並產生最佳化的程式碼，例如: 我們有 math.js、event.js、btn.js、person1.png、cat.png、index.css 及 about.css 三個 js 檔案、兩個 png 圖片檔、兩個 css 檔，共七個檔案，在打包後會壓縮成一個檔案叫 bundle.js ，而前面的七個檔案就被包在裡面，執行之後就會在 html 上運行並顯示出來。\n \nCSS Selector 權重的計算方式為何？\n\n基本的權重大小: !important > inline style > ID > Class > Elements > *\n",
      "createdAt": 1608746453293
    },
    {
      "id": 14,
      "userId": 1,
      "title": "week14",
      "body": "\nAWS 主機部署心得\n\n本次部署我採用的是，超級挑戰題-Docker 部署，用 Docker 把 Nginx, PHP, MYSQL 容器化之後上傳到 AWS 的 EC2 主機上並運行，以下說說遇到的困難及挑戰。\n \n系統問題:\n\n由於 Docker 的核心是 Linux ，我家裡的電腦系統是 Windows 專業版 ，在下載 Docker 安裝的過程中遇到了需要開 Hyper-V 的問題，而在公司電腦上則是發生了 Windows 版本是家用版，需要更新成 2004 版才支援 Linux 子系統，否則無法使用 Docker 的問題；而在容器化 MySQL 的部分，則是因 Windows 版本問題，發生了在公司電腦上可以直接映射本地資料夾到 MySQL 容器裡的資料夾，在家裡電腦做同樣的事卻會報錯的情形，解決方式，直接以容器建立 Volume 後映射。\n \n權限問題:\n\n在建立 MySQL 容器之後，打開網頁發現沒有資料，從 developer tool 中發現，無法存取資料，查了資料之後才知道， ROOT 有安全性問題，所以無法直接存取資料，解決方式則是新建一個 User 然後賦予權限。\n \n連線問題:\n\n由於每個容器都是獨立的，且各自有自己的 IP ，所以要將每個容器都看作是獨立的主機，因此連線要記得設定，例如: 建立一個 network ，然後將每個容器指定在這個 network 底下，這樣容器間就能互連，跟真實世界的主機一樣了。\n \n主機設定問題:\n\n老實說這不太算是問題，頂多是比較繁雜而已，AWS 的服務很多，所以查資料會出現很多種部署的方式，當下真的不知道該如何選擇，所以就依照最簡原則去篩選掉複雜的，只看最簡單的教學文，當然，資料也是散散的，要靠自己把各種磚塊拼湊起來，然後，由於主機都是 Linux 的，所以還要根據教學文去查一下教學裡的指令到底有什麼作用，惡補了一下基本的 Linux 指令使用方法-.-，總之，最後總算還是順利的把 Docker 包好的 Nginx, PHP, MySQL 給上傳到主機上並運行了，當然，也順利的把網域名給映射到主機上了。\n \n總結:\n\nDocker 對 Windows 使用者真的很不友善啊…各種不支援，或是莫名其妙的錯誤…好在最後還是成功部署了~YA!\n\n在學習使用 Docker 及 Nginx 的過程中，找了許多的資料，學到了 Nginx 跟 Apache 的不同，學到了 Docker 是什麼，為什麼要用 Docker 以及如何設定 Nginx 及 Docker ，不敢說自己真正學會了，頂多只能說知道怎麼讓它動起來而已，因為有太多的設定及細節都還沒來得及吸收理解，就待往後需要用到的時候再來理解吸收吧!\n\n然後…學習新東西真的是滿累人的，尤其作業系統支援度低，出現各種莫名其妙的錯誤的時候真的會覺得很幹，但最後成功把網站部署到主機上並且看到網站成功的運行的時候，真的是很有成就感呢~!\n\n最後期許自己可以一直保持學習動力，活到老學到老!!\n \n什麼是 DNS？Google 有提供的公開的 DNS，對 Google 的好處以及對一般大眾的好處是什麼？\n\nDNS 是 Domain name system 的縮寫，DNS 系統主要的功能是，做為網域名稱與 IP 位址相互之間的轉換，例如: 網址 john.com，將其對映到 IP 位址 127.127.127.7，如此一來，只要輸入 john.com 就會導向 127.127.127.7 這個伺服器位址了，最大的功用是將 IP 位址變成人類容易記憶的，有意義的名稱，使人們不用再記不容易記憶的 IP 數字。\n\nDNS 對 Google 的好處是，Google 可以利用 DNS 伺服器去搜集使用者輸入的網址，並將其用來優化搜尋引擎，或是了解趨勢進行分析統計，做為 Google 設計其它產品的參考，或者是用來做為插入廣告使用。\n\n使用 Google DNS 伺服器對一般民眾的好處是:\n\n    比 ISP 或是 小公司提供的 DNS 伺服器快\n    過濾掉有惡意軟體的網站。\n    可靠且安全性高\n\n \n什麼是資料庫的 lock？為什麼我們需要 lock？\n\nLock 指的是當資料庫有多個 Transaction 在進行讀寫操作時，會將資料鎖起來，使其它的 Transaction 無法在同一時間進行操作，以維持資料的完整性，而 Lock 分為兩種，共享鎖及互斥鎖，共享鎖是當 Transaction 要讀取某資料時，必須要先取得的鎖，共享的意思則是，當其它 Transaction 也要讀取同筆資料時，也會取得共享鎖，並得以讀取該資料，而互斥鎖則是在同一時間內只能被一個 Transaction 使用，如其它 Transaction 也要取得同一份資料的互斥鎖，則必須等待上一個佔用互斥鎖的 Transaction 結束才能取得。 共享鎖簡稱為 S Lock，而互斥鎖稱為 X Lock。\n\n我們需要 Lock 是因為要保持資料的完整性，Lock 本身就代表了 Transaction 的其中一個特性， Isolation 隔離性，用來防止多個 Transaction 對資料交叉執行造成資料衝突，進而使數據前後不一。\n \nNoSQL 跟 SQL 的差別在哪裡？\n\n    SQL 是關聯性資料庫，NoSQL 是非關聯性資料庫。\n    SQL 資料庫使用結構化查詢語言，並且有預先定義好的 schema，而 NoSQL 資料庫則是為非結構化數據提供了動態 schemas\n    SQL 資料庫是垂直擴展的，而 NoSQL 資料庫則是水平擴展的。\n    SQL 資料庫是基於表的、而 NoSQL 資料庫則是文件、鍵值、圖表或是寬欄的儲存庫\n    SQL 資料庫較適合多行 Transactions，而 NoSQL 則是比較適合 非結構化的資料，像是，文件或是 JSON。\n\n \n資料庫的 ACID 是什麼？\n\nACID 是 Transaction 四個特性的首字母組合起來的縮寫\n\nA: Atomicity 原子性， Transaction 中的所有操作，要嘛全部完成，或者全部不完成，不會在中間就結束。如果 Transaction 時發生錯誤，會 Rollback 到 Transaction 開始前的狀態，\n\nC: Consistency 一致性，在 Transaction 開始前或結束後，資料庫的資料都是完整的。寫入的資料要完全符合所有預設的約束、觸發器、級聯回滾等。\n\nI: Isolation 隔離性，當多個 Transaction 並發執行時，防止多個 Transaction 交叉執行而導致數據的不一致，事務隔離分為不同級別，包括， Read uncommitted、Read committed、repeatable read、和 Serializable。\n\nD: Durability 持久性，當 Transaction 處理結束後，對數據的修改是永久的，即使系統故障也不會丟失。\n",
      "createdAt": 1608746453293
    },
    {
      "id": 15,
      "userId": 1,
      "title": "week15",
      "body": "\n十一到十五週心得\n \n第十一週心得\n\n這一週印象最深刻的就是關於資安漏洞的部分的，做好的留言板有些因偷懶，\n沒有用 Bind 防止 SQL 注入以及沒有過濾 html 標籤，導致留言板被同學狂插入 script 標籤，\n導致留言板直接消失，不然就是被老師 SQL 注入 爆密碼 XD，這下真的完全記在腦海裡，絕對不會忘囉~\n\n再來就是延伸挑戰題的部份，當下看到的時候就覺得有點麻煩，因為可能會花比較多時間，怕沒辦法在一週內完成，\n但最後，作業 1 跟作業 2 的挑戰題都完成了，也從中學到一些設計資料庫的知識，以及權限管理等，滿有成就感的^^\n\n至於最特別的部份就是作業 2 了，因為不想要跟範例一樣醜醜得，所以特地去找了一些樣板，再自己改一改之後變成自己喜歡的板面，\n然後裡面的 PHP 程式碼則是找資料，看別人怎麼做的，然後自己改一改變成自己需要的功能這樣，雖然參考的部份還滿多的，但真的，\n從中學到很多關於知識，例如: 將公用程式碼與管理員程式碼分開成個別檔案與資料夾、創建一個資料表用來關聯兩個不同資料表，\n或是將程式碼寫的更簡潔等，雖然為了這個作業，花了許多時間在 Debug ，但在看到部落格會動，各個功能都沒問題的時候，真的很感動诶 QQ\n \n第十二週心得\n\n這一週主要是學習 jQuery 及 Bootstrap 的使用及做出後端 API，然後用前端 JS 去串接，這一週相對於第十一週來說簡單許多，\n因為回歸到了熟悉的前端 JavaScript 的部分(當下真的有種老友好久不見的感覺，哈)，在這一週裡，真的徹底的體會到 jQuery 有多方便與強大!\n本來要花好幾行的事情，jQuery 只要一行就搞定了! 真是太神奇啦!!\n這週的留言板作業用了 jQuery 及 Bootstrap，不到十分鐘就完成了，難怪\n大家都要使用這些套件，可以大幅減少開發速度呢! 以下說作業心得\n\n作業 1 是單純的 html+JavaScript 的留言板，如上面所說，不到十分鐘就搞定了!，然後載入更多的功能，之前的作業就已經做過了，所以就不再贅述，\n主要是體會 jQuery 及 Bootstrap 的強大。\n\n作業 2 則是 Todo list ，這個作業是第七週的延伸，原本是要把只有新增、刪除及標記的 Todo list 加上編輯、清空及篩選等功能，使其完整，\n但由於我在第七週就已經把篩選之外的功能都完成了，所以就直接拿第七週作業來改了，單純前端的部份都滿簡單的，難點是按下儲存按鈕之後要把 todo 狀態傳到 server 儲存起來並拿到回傳的 id 這部分，\n一開始覺得好像有點難，但在仔細思考之後會發現，其實不難，只要 post 資料到 server 儲存之後，server 再透過 mysqli_insert_id 這個函式就能取得剛剛 post 的資料\n的 id 了，能夠拿到 id 就很好辦啦，確認拿到 id 後，呼叫函式帶上 id 並更新網址的 history 就順利解決了，接下來只要加上每次載入頁面都執行一個函式，檢查是否網址有帶 id 的程式碼，\n就可以做到載入頁面後自動串接 api 跟 server 撈資料了。\n\n前後端分離使用者體驗真的好很多呢，不用一直看到頁面跳轉，而是只更新必要區塊裡的內容，清爽度爆表_\n \n第十三週心得\n\n這一週除了 Gulp 以外的工具都碰過了，所以心得較少，最重要的是知道 gulp 是任務執行器，可以執行任何你寫在裡面的任務，\n而 Webpack 是打包工具，專門用來將 js、css、圖片等檔案打包成一個檔案，壓縮優化檔案大小。\n以下是本週作業心得\n\n作業 1，用 CSS 預處理器改寫部落格的 CSS 檔案，在使用過預處理器寫 CSS 後，覺得好懂，也好寫很多，因為使用 CSS 預處理器，\n可以用嵌套的方式寫 CSS，直接把子 CLASS 寫進父 CLASS 的大括號裡，這樣子的寫法對父 CLASS 底下有哪些子 CLASS 就會清楚很多，一目瞭然，\n以及可以把顏色啊，寬高啊，等屬性用全域變數存起來並使用在 CLASS 裡，好處是要更改屬性時，不用一個一個找 CLASS 去改屬性，只要改變數存的屬性就可以了，\n另外還有一點就是，可以使用函式去根據條件改變屬性，使 CSS 的靈活度增強許多。\n\n作業 2 則是學到了如何用 Webpack 將 js 打包成 plugin 以及要寫 plugin 應該要注意的那些問題，例如: CLASS 的衝突以及給 Site key 讓每個插入的留言板都是獨立的\n，彼此的留言不會重複。\n\n作業 3 是將第八週原本用 XMLHttpRequest 串接 API 的 Twitch 作業改成用 fetch 去串 API，由於我本來就是用 fetch 去串，所以就直接交了。\n \n第十四週心得\n\n本週主要就是部署，部署本身不難，難的是我硬要挑戰在 Windows 系統用 Docker 部署，\n結果發生了許多 Windows 造成的錯誤，延遲了交作業的時間 QQ，以下說說作業心得\n\n作業 1 這個作業有點刁鑽，因為不知道要畫成怎樣，所以就網路上查資料，然後參考一下人家的架構，就抄一抄了 XD，不過在這個過程中確實學到了許多在設計一個系統時應該要考慮的點，\n例如，算出一天會有多少個創建短網址的要求及一天會有多少個獲取長網址的要求，進而推算出未來五年內的儲存空間要有多大，或是根據前述的要求去推算每秒的傳輸量是多少，\n來決定要創建幾個分流 Server 以及考慮到回應的速度而設置 cache server，優化存取速度等，總之，學到了很多知識，雖然不知道未來會不會用到 XD。\n\n作業 2 Docker 的教學網路上有很多，所以上手不難，難的是在部署的過程中，因 Windows 系統版本所造成的錯誤及問題，例如: 家用版可以直接創建一個本地資料夾用來映射 mySQL 容器裡的資料夾，\n而專業版不行，解決的方式為直接創建一個 volume 的容器來保存 mySQL 的資料，還有家用版需要將版本更新成 2004 才能支援 Linux 子系統，以及專業版需要進 BIOS 把 虛擬化功能打開才能使用 Docker 的問題，\n除此之外，還有 mySQL 的權限問題，需要將使用者改成任何網域都能存取，這樣才能連接到 mySQL 資料庫，嗯…最後就是關於 AWS，它上面太多服務了，根本不知道要選哪個啊 XDD。\n \n第十五週心得\n\n本週我主要就是把之前累積的文章，教學補充影片補完，例如把 14 週資料庫的 View、 Stored Procedure 與 Trigger 影片看完，以及把 Fetch 與 Promise 系列影片看完這樣，\n然後這一週的\"網站前後端開發基礎測試\"，我做完的結果是，錯的滿多的 XD，只好把全部題目跟解答 k 個幾遍，以求內化 QQ，\n這一週就差不多這樣了，還有很長的路要走，要不斷的充實自己才行，畢竟時間不等人，為自己加油!!!\n",
      "createdAt": 1608746453293
    },
    {
      "id": 16,
      "userId": 1,
      "title": "week16",
      "body": "\n程式碼如下\n\nconsole.log(1)\nsetTimeout(() => {\n  console.log(2)\n}, 0)\nconsole.log(3)\nsetTimeout(() => {\n  console.log(4)\n}, 0)\nconsole.log(5)\n\n \n輸出結果為\n\n1, 3, 5, 2, 4\n \n執行步驟\n\n    進入 main (全域環境)\n    讀到第一行，執行 console.log(1)，印出 1\n    讀到第二行，將 setTimeout 函式放進 Stack 並執行\n    執行後將匿名箭頭函式 1 放到 callback queue\n    讀到第五行，執行 console.log(3)，印出 3\n    讀到第六行，將 setTimeout 函式放進 Stack 並執行\n    執行後將匿名箭頭函式 2 放到 callback queue\n    讀到第九行，執行 console.log(5)，印出 5\n    Stack 裡的函式已清空\n    等待 0 秒後將 callback queue 裡的匿名箭頭函式 1 放進 Stack\n    執行匿名箭頭函式 1，執行 console.log(2)，輸出 2\n    等待 0 秒後將 callback queue 裡的匿名箭頭函式 2 放進 Stack\n    執行匿名箭頭函式 2，執行 console.log(4)，輸出 4\n    callback queue 裡的函式已清空\n    程式結束\n\n \n原因\n\nJavaScript 本身是單一 Stack 的程式語言，但在瀏覽器的執行環境下，可以運用瀏覽器提供的\ncallback queue 做到非同步處理，像 setTimeout 就是瀏覽器所提供的函式。運作原理是，瀏覽\n器本身有個事件監聽器，當監聽到有非同步處理的程式碼時，例如: setTimeout，就會將傳進 set\nTimeout 的回呼函式放進 callback queue 裡，當 JavaScript 本身 Stack 裡的函式都執行完畢後，就會將 callback queue 裡的回呼函式一個一個放進 JavaScript 本身的 Stack 裡面執行，\n從而做到非同步處理的效果。\n \n程式碼如下\n\nfor(var i=0; i<5; i++) {\n  console.log('i: ' + i)\n  setTimeout(() => {\n    console.log(i)\n  }, i * 1000)\n}\n\n \n輸出結果為\n\ni: 0\ni: 1\ni: 2\ni: 3\ni: 4\n\n5\n5\n5\n5\n5\n \n執行步驟\n\n    讀到第一行，for 迴圈，設 var i 為 0，判斷 i 是否小於 5 ，是，執行迴圈裡的程式碼\n    讀到第二行，執行 console.log(‘i:’ + i)，變數 i 為 0，印出 i: 0\n    讀到第三行，執行 setTimeout，將箭頭逆名函式 1 放進 callback queue，設定 i = 1 * 1000 秒後執行該箭頭逆名函式 1，i++\n    回到第一行，for 迴圈，i 為 1 判斷 i 是否小於 5 ，是，執行迴圈裡的程式碼\n    讀到第二行，執行 console.log(‘i:’ + i)，變數 i 為 1，印出 i: 1\n    讀到第三行，執行 setTimeout，將箭頭逆名函式 2 放進 callback queue，設定 i = 2 * 1000 秒後執行該箭頭逆名函式 2，i++\n    回到第一行，for 迴圈，i 為 2 判斷 i 是否小於 5 ，是，執行迴圈裡的程式碼\n    讀到第二行，執行 console.log(‘i:’ + i)，變數 i 為 2，印出 i: 2\n    讀到第三行，執行 setTimeout，將箭頭逆名函式 3 放進 callback queue，設定 i = 3* 1000 秒後執行該箭頭逆名函式 3，i++\n    回到第一行，for 迴圈，i 為 3 判斷 i 是否小於 5 ，是，執行迴圈裡的程式碼\n    讀到第二行，執行 console.log(‘i:’ + i)，變數 i 為 3，印出 i: 3\n    讀到第三行，執行 setTimeout，將箭頭逆名函式 4 放進 callback queue，設定 i = 4* 1000 秒後執行該箭頭逆名函式 4，i++\n    回到第一行，for 迴圈，i 為 4 判斷 i 是否小於 5 ，是，執行迴圈裡的程式碼\n    讀到第二行，執行 console.log(‘i:’ + i)，變數 i 為 4，印出 i: 4\n    讀到第三行，執行 setTimeout，將箭頭逆名函式 5 放進 callback queue，設定 i = 5* 1000 秒後執行該箭頭逆名函式 5，i++\n    回到第一行，for 迴圈，i 為 5 判斷 i 是否小於 5 ，否，迴圈結束\n    Stack 已清空\n    等待 0 秒後將 callback queue 的箭頭逆名函式 1 放進 stack 並執行，此時 var i 為 5 ，\n    console.log(i) 印出 5\n    等待 1 秒後將 callback queue 的箭頭逆名函式 2 放進 stack 並執行，此時 var i 為 5 ，\n    console.log(i) 印出 5\n    等待 2 秒後將 callback queue 的箭頭逆名函式 2 放進 stack 並執行，此時 var i 為 5 ，\n    console.log(i) 印出 5\n    等待 3 秒後將 callback queue 的箭頭逆名函式 2 放進 stack 並執行，此時 var i 為 5 ，\n    console.log(i) 印出 5\n    等待 4 秒後將 callback queue 的箭頭逆名函式 2 放進 stack 並執行，此時 var i 為 5 ，\n    console.log(i) 印出 5\n    callback queue 已清空\n    Stack 已清空，程式結束\n\n \n原因\n\n迴圈的輸出結果跟 setTimeout 不一致的原因為 var 這個變數的 Scope 是 Function Scope，\n而在 main 全域環境的情況下，for(var i = 0; i < 5; i++) 相當於以下\n\nvar i = 0\nfor(i < 5; i++)\n\n因此，var i 是全域變數，而在傳進 setTimeout 的箭頭匿名函式，是執行一段 console.log(i)，印出 i 這個變數的值，\n但由於傳進 setTimeout 的回呼函式不會當下執行，所以無法立即的印出當下 var i 的值， 而是在迴圈結束後才開始依照順序執行箭頭匿名函式並印出 var i 的值；\n會印出 5 的原因是，迴圈結束後，var i 的值，已經變成 5 了，而箭頭匿名函式在自己的 Scope 找不到 i 這個變數的情況下，\n會往上一層 Scope 找，而在上一層 Global Scope 中，找到了 var i ，因此印出 Global Scope 的 var i 的值，5，像下面例子\n\nvar i = 0;\n\nfor(; i < 5; i++) {\n  console.log('i: ' + i); // 這裡會輸出 0, 1, 2, 3, 4\n}\n\n// 此時 var i 的值已經變為 5\n\nfunction test() {\n  console.log(i);\n}\ntest(); // 印出 5\n\n所以 for 迴圈裡的輸出結果才會跟 setTimeout 不一樣，而傳進 setTimeout 裡的延遲秒數 i * 1000的部份，\n這個 i 會跟 for 迴圈印出的 i 的值是一致的，因為是傳當下的值進去 setTimeout 並執行 setTimeout ，而不是迴圈完之後才執行，\n所以 i * 1000在每次迴圈時會是\n\nsetTimeout(() => {\n    console.log(i)\n  }, 0 * 1000)\nsetTimeout(() => {\n    console.log(i)\n  }, 1 * 1000)\nsetTimeout(() => {\n    console.log(i)\n  }, 2 * 1000)\nsetTimeout(() => {\n    console.log(i)\n  }, 3 * 1000)\nsetTimeout(() => {\n    console.log(i)\n  }, 4 * 1000)\n\n因此，會先執行延遲 0 秒的第一個箭頭匿名函式，執行完 1 秒後再執行第二個箭頭匿名函式，執行完後，\n前面執行箭頭匿名函式的 1 秒 + 等待 1 秒 = 2 秒，後再執行第二個箭頭匿名函式，執行完後，\n前面執行箭頭匿名函式的 1 秒 + 1 秒 + 等待 1 秒 = 3 秒，後再執行第三個箭頭匿名函式…以此類推，\n最後結果就是看起來是每隔一秒執行一次箭頭匿名函式。\n \n程式碼如下\n\nvar a = 1\nfunction fn(){\n  console.log(a)\n  var a = 5\n  console.log(a)\n  a++\n  var a\n  fn2()\n  console.log(a)\n  function fn2(){\n    console.log(a)\n    a = 20\n    b = 100\n  }\n}\nfn()\nconsole.log(a)\na = 10\nconsole.log(a)\nconsole.log(b)\n\n \n輸出結果為\n\nundefined\n5\n6\n20\n1\n10\n100\n \n執行步驟\n\n    進入 main 全域環境，宣告 var a、 宣告 fn 函式\n    設 var a = 1;\n    執行 fn()，進入 fn 函式的 Scope\n    宣告 var a 及 fn2 函式，並提升到 fn 函式的最上方\n    執行 console.log(a)，此時 var a 尚未賦值，印出 undefined\n    設 var a = 5\n    執行 console.log(a)，印出 5\n    a++，此時 var a 為 6\n    再宣告一次 var a ，由於 var a 已經宣告過了，所以沒有效果\n    執行 fn2()，進入 fn2 函式的 Scope\n    執行 console.log(a)，在 fn2 的 Scope 沒有 a 這個變數，所以往上找 fn 函式，fn 函式裡有 a 並且值是 6\n    ，印出 fn 函式裡 a 變數的值，6\n    重新賦值 a = 20\n    重新賦值 b = 100，fn2 的 Scope 沒有 b ，往上 fn 函式找 b ，也沒有，再往上 Global 找 b，也沒有，因此宣告 var b = 100\n    fn2 函式執行結束，回到 fn 函式\n    執行 console.log(a)，由於 a 已經在 fn2 函式裡被重新賦值 a = 20 了，因此印出 20\n    fn 函式執行結束，回到 Global main\n    執行 console.log(a)，此時 Global 的 var a 變數的值還是 1 ，所以印出 1\n    重新賦值 a = 10\n    執行 console.log(a)，印出 a 重新賦值後的值，10\n    執行 console.log(b)，由於 b 在 執行 fn2 函式的時候因找不到 b 而直接在 Global 全域環境，宣告並賦值 var b = 100 ，因此印出 100\n    程式執行完畢\n\n \n原因\n\nJavaScript 在執行程式的時候，會先經過預編譯的階段，將執行環境中的變數及函式都放到一個叫做 Variable Object 的物件裡，之後再一行一行的執行，透過這種預編譯的過程，達成函式之間可以互相呼叫而不會報錯，這種行為叫做提升。而變數的提升跟函式的提升又不一樣，例如\n\nfunction test() {\n  console.log(a);\n  var a = 5;\n}\n\n我們看到，在第三行是 var a = 5 ，但實際上執行的時候是分成兩個步驟執行的，先宣告變數 var a，宣告完之後再賦值 a = 5 ，因此提升的時候，是把宣告 var a 這個動作提升上去，並沒有賦值，因此在 console.log(a) 的時候就會發生 undefined 的情況\n\n// 實際執行時是像這樣子，所以出現 undefined\nfunction test() {\n  var a;\n  console.log(a);\n  a = 5;\n}\n\n而在子函式裡找不到變數，繼而往上找的情況是因為有 Scope chain 的原因，在進入全域環境，及宣告函式的時候，會一併將 函式的 Scope 一併設置好，用一段程式碼來舉例:\n\nvar a = 1;\nfunction test() {\n  var b = 2\n  function innerTest() {\n    console.log(a);\n    console.log(b);\n  }\n  innerTest();\n}\n\nfunction test2() {\n  console.log(b);\n}\ntest(); // 裡面的 innerTest 會印出 1 跟 2\ntest2(); // 會報錯，b is not defined\n\n在上面的程式碼裡，用 Scope Chain 來呈現會長這樣\n\ninnerTest execution context\n{\n  AO: {\n  },\n  // innerTest 自己的 Scope 加 test EC 的 Scope 再加上 Global EC 的 Scope\n  scope: [innerTest EC, test EC, Global EC]\n}\n\ntest2 execution context\n{\n  AO: {\n  },\n  scope: [test2 EC, Global EC] // test2 自己的 scope 加上 Global EC 的 scope\n}\n\ntest execution context\n{\n  AO: {\n    b: 2\n    innerTest: FUNCTION\n  },\n  scope: [test EC, Global EC] // test 自己的 scope 加上 Global EC 的 scope\n}\n\nGlobal execution context\n{\n  VO: {\n    a: 1\n    test: FUNCTION\n    test2: FUNCTION\n  },\n  scope: [Global EC] // 只有自己的 Scope\n}\n\n因此當執行 innerTest 函式時，在自己的 Scope 找不到變數 a 的情況下就會往上一層 scope test 函式裡找，而 test 函式的 scope 裡也沒有 變數 a ，所以往更上層 Global scope 找，找到 var a = 1 ，因為這樣才得以印出 1，console.log(b)，也是一樣的\n道理，在往上層 scope 找時，發現在 test 函式的 scope 就有變數 var b = 2 ，所以可以印出 b，而另一個 test2 函式，由於它的 scope chain 上只有自己跟 Global Scope ，所以存取不到在 test 函式裡的 var b = 2 ，執行會出現 b is not defined。\n\n在這 hw3 所給的程式碼中，就是因為上述的，\"提升\"及 \"Scope chain\"的原因， 輸出結果才會是\n\nundefined\n5\n6\n20\n1\n10\n100\n\n \n程式碼如下\n\nconst obj = {\n  value: 1,\n  hello: function() {\n    console.log(this.value)\n  },\n  inner: {\n    value: 2,\n    hello: function() {\n      console.log(this.value)\n    }\n  }\n}\n\nconst obj2 = obj.inner\nconst hello = obj.inner.hello\nobj.inner.hello() // ??\nobj2.hello() // ??\nhello() // ??\n\n \n輸出結果為\n\n2\n2\nundefined\n \n執行步驟\n\n    宣告 const obj 並賦值為物件，內容物為 value 1, hello 函式, inner 物件，inner 物件內容物為，\n    value 2, hello 函式\n    宣告 const obj2 為 obj.inner 物件\n    宣告 const hello 為 obj.inner.hello 函式\n    執行 obj.inner.hello()，此時呼叫的是 inner 物件底下的 hello 函式，因此 this 指向的是 inner 物件，印出 inner 物件的 value 的值，2\n    執行 obj2.hello()，變數 obj2 的值被設為 obj.inner 物件，所以呼叫的是 inner 物件底下的 hello 函式，因此 this 指向的是 inner 物件，印出 inner 物件的 value 的值，2\n    執行 hello()，變數 hello 的值被設為 obj.inner.hello 函式，所以呼叫 hello 執行的時候，是直接執行函式，而因為不是在 obj 物件底下，也不是在 inner 物件底下，所以 this 的值會是 window 物件(在瀏覽器執行的話)，而在 window 物件底下並沒有一個叫 value 的變數，所以印出 undefined\n    程式結束\n\n \n原因\n\nJavaScript 的 this 所指向的物件是根據呼叫 this 的地方所決定的，例如在瀏覽器底下執行\n\n  console.log(this);\n\n會印出 Window 物件，因為在瀏覽器環境底下 Window 就是全域環境物件，所有全域 var 及 function 的宣告都會被儲存為 Window 物件底下的 Property ，例如\n\nvar value = 'window';\nconsole.log(this.value) // 會印出 'window'\n\n而如果我們用 console.log(this) 去查看的話，會發現\n\nconsole.log(this);\nWindow {\n  ...\n  value: \"window\"\n}\n\nWindow 物件底下出現了我們剛剛用 var 宣告的 value 變數及它的值，“window”，那要是我們沒宣告 var value = window 呢?\n\nconsole.log(this.value) // undefined\n\n既然我們沒宣告 var value = window 那也就不會在 Window 物件底下建立一個叫 value 的 property，所以理所當然會印出 undefined。\n\n在懂了 this 是根據呼叫它的位置去決定它的值是那一個物件及知道了如果沒在全域環境宣告 var value 會印出 undefined 之後，我們就能回到題目並了解會輸出什麼了。\n\n首先，我們全域宣告了一個物件\n\nconst obj = {\n  value: 1,\n  hello: function() {\n    console.log(this.value)\n  },\n  inner: {\n    value: 2,\n    hello: function() {\n      console.log(this.value)\n    }\n  }\n}\n\n這個 obj 物件裡面還有一個叫 inner 的物件，這要記住。\n然後再宣告兩個變數\n\nconst obj2 = obj.inner\nconst hello = obj.inner.hello\n\n這裡我們將變數 obj2 指向 obj 物件裡的 inner 物件，所以 obj2 = inner 物件，然後將 變數 hello 指向 obj 物件裡的 inner 物件裡的 hello 函式，所以 hello = function，看起來是像這樣\n\nconst obj2 = inner {\n  value: 2,\n  hello: function() {\n    console.log(this.value);\n  }\n};\nconst hello = function() {\n  console.log(this.value);\n}\n\n這樣子寫就能很清楚的知道變數 hello 的值是一個匿名函式，而不是物件。\n\n接下來執行函式\n\nobj.inner.hello()\n\nobj 是一個物件，而在這個物件裡面又有一個叫 inner 的物件，inner 物件裡有個叫 hello 的函式，而上面那一段程式碼代表的是透過 inner 物件呼叫 hello 函式，因為是透過 inner 物件呼叫 hello 函式的，因此 hello 函式裡 this 的值就會是 inner 物件，而 this.value 就會去尋找 inner 物件裡的 value property 並印出它的值，\n這裡 value 的值是 2 ，所以印出 2。\n\n接下來\n\nobj2.hello()\n\n我們上面已經知道宣告 obj2 發生了什麼事了，所以直接拿來用\n\nconst obj2 = obj.inner\n\n實際上等於\n\nconst obj2 = inner {\n  value: 2,\n  hello: function() {\n    console.log(this.value);\n  }\n};\n\n所以變數 obj2 指向的是 inner 物件，既然知道指向的是 inner 物件，那麼在執行 obj2.hello() 時，就能很明確的知道 this 指的是 inner 物件，所以 console.log(this.value) 會印出 2 囉。\n\n最後是執行 hello 函式\n\nhello()\n\n剛剛已經解釋過了，我們可以把\n\nconst hello = obj.inner.hello\n\n看成\n\nconst hello = function() {\n  console.log(this.value);\n}\n\n所以我們在用 hello 變數去呼叫函式的時候，因為我們是在全域環境裡執行這個函式，所以\nthis 會指向 Window 物件，而我們並沒有在全域宣告 var value 的變數，所以 Window 物件底下不會有 value 的 property ，因此會印出 undefined。\n\n最後，我們得到的輸出結果就是\n\n2\n2\nundefined\n\n \n這週學了一大堆以前搞不懂的東西，你有變得更懂了嗎？請寫下你的心得。\n\n的確變得更懂了呢~!\n尤其是 Hoisting 跟 Scope chain ，這兩個部份，\n了解了 Hoisting 跟 Scope chain 是怎麼運作的，知道了有 execution context , variable object 及\nscope property 明白了 js 引擎是怎麼一步一步預編譯，將變數及函式都先放進 variable object 再\n真正的一行一行執行程式碼。\n\n個人認為這一堂的價值非常高，學到這些之後，在開發的時候就能知道要如何寫出漂亮，\n清楚的程式碼，將出 bugs 的情況降低，而在維護他人的程式碼時，也能更容易知道出錯的原因是什麼\n進而加快解決 bugs 的速度，對於整體開發或維護來說，都是有很大益處的。\n\n個人覺得每個學 js 的新手都應該要熟悉這些觀念才對，有了這些基礎，\n就能一眼知道程式碼在執行時到底做了些什麼，閱讀理解程式碼的能力提高之後，\n學習速度會快上很多。\n\n感謝 Huli 老師做出了這麼高質量的課程，希望 Huli 老師能多出一些關於 JS 引擎技術的文章及課程^_^。\n",
      "createdAt": 1608746453293
    },
    {
      "id": 17,
      "userId": 1,
      "title": "week17",
      "body": "\n什麼是 MVC？\n\nM = Model (資料模型）\nV = View（畫面）\nC = Controller （控制器）\n\nMVC 主要是把程式碼分成資料模型、畫面及控制器，以便維護及修改，增加程式碼可復用性及可擴充性。\n\nMVC 架構\n\n    定義好資料模型的資料及其功能，例如：電視台列表資料、跳轉到某一電視台的功能。\n\n    定義好控制器向資料模型請求執行資料模型的跳轉功能，得到要跳轉的電視台號碼後傳送至畫面的功能。\n\n    定義好畫面收到控制器傳來的電視台號碼後顯示該電視畫面的功能。\n\n \n請寫下這週部署的心得？\n\nHeroku 跟 AWS 相比之下， Heroku 的部署方式真是太方便快速了！ 按照官方文件操作，五分鐘內就能部署完畢，而且附加資料庫插件的功能也很方便，只需要點擊附加，就幫你建好資料庫及資料庫帳號密碼了，太讚了！\n\n部署時遇到的難點為，使用Node File system套件上傳圖片的話，必須要使用 copyfile 及 unlink 的方式去搬移圖片，而不能使用rename 的方式，否則會報錯QQ\n \n寫 Node.js 的後端跟之前寫 PHP 差滿多的，有什麼心得嗎？\n\n使用了 ORM 做為 Model 以及使用 EJS 做為 View 之後，剩下的就是撰寫 Controller 去串資料並顯示在 View 上，這讓開發速度快上許多，而且程式碼也不會像寫 PHP 一樣，邏輯跟畫面全部混在一起，要修改的時候，難以修改。\n\n而 Express 的功能，則使得開 Server 、設 Router 極簡化，再加上 middle ware 的功能，使得處理任何請求及回應都不是問題。\n\n所以，我個人的感覺是，使用 Node js 開發，會比用 PHP 容易得多，因為很多事情套件都處理好了，我們所要做的事情就是決定要如何串資料及顯示畫面而已，相比 PHP 快速很多。當然，最棒的是，前端跟後端都是 JS ，學一種，前端跟後端通吃。\n",
      "createdAt": 1608746453293
    },
    {
      "id": 18,
      "userId": 1,
      "title": "week18",
      "body": "什麼是反向代理（Reverse proxy）？\n\n什麼是 reverse proxy ?\n\nReverse proxy 叫做反向代理，跟 Forward proxy 正向代理不一樣的是，正向代理是代理 clients 的請求，而反向代理是代理 servers 的回應。\n\nReverse proxy 範例：\nClient 端 > Reverse proxy server > Server端（1至多個 Servers ）\n\nClient 端發送請求到 Reverse proxy server ，然後 Reverse proxy server 根據請求或是流量配置，將請求導向想對應的 Server。\n\nReverse proxy 的優點\n\n    負載平衡：\n    商業化的網站每天的流量都很大，如果只有一台 Server 會導致流量超過伺服器處理能力而導致回應速度過慢甚至當機，但如果有許多台 Server 去平均分配流量，就不會發生流量過大而當機或是回應處理速度過慢的事情了。\n\n    保護伺服器安全\n    由於 Client 端是透過 Reverse proxy server 導向到真正的 Server 因此 Client 端不會知道真正 server 的 IP 地址，使得例如 DDoS 的攻擊只能攻擊到 Reverse proxy server，而無法攻擊到真正提供服務的 Server ，從而保護了伺服器安全。\n\n    Caching 快取\n    Reverse proxy server 可以將資料快取起來，以提供更快的回應速度。例如，台灣要連到在美國被代理的網站，會透過台灣當地的 Reverse proxy server 導向到美國被代理的網站，導向的同時， Reverse proxy server 會暫時快取回應的資料，下次連線時，台灣當地的 Reverse proxy server 會直接以快取的資料回應 Client ，由於是台灣當地 Reverse proxy server 直接回應快取資料給 Client 端，速度上就快了許多。\n\n \n什麼是 ORM？\n\nORM = Object-Relational-Mapping = 物件關係對映\n\n簡單的說就是，將例如以下 query\n\nSELECT * FROM users WHERE email = ‘test@test.com’;\n\n封裝成物件，變成以下程式碼的技術。\n\nvar orm = require(‘generic-orm-libarry’);\nvar user = orm(“users”).where({ email: ‘test@test.com’ });\n\n透過將 query 用程式語言封裝成物件之後，使用者只要引入 ORM 套件，並按照文件教學使用\n跟 query 相對應的 method 就可以跟資料庫互動，新增、刪除、更新及查詢，而不用再寫 query 字串了。\n\n優點\n\n    可以用你所使用的程式語言寫 ORM ，而不用使用不熟悉的 SQL 語法跟資料庫互動。\n\n    將資料庫系統抽象化，因此從例如，MySQL 轉換到 PostgreSQL 或其它資料庫系統都非常容易。\n\n    使用 ORM 寫 query 的執行速度會優於自己寫 SQL 語法。\n\n缺點\n\n    初始化 ORM 配置較不易上手\n\n    在沒碰過資料庫的情況下就直接使用 ORM ，可以會使你不了解到底資料庫是如何運作的，\n    而這對一個開發者來說，不是一件好事。\n\n \n什麼是 N+1 problem？\n\nN+1 problem 指的是，原本用 SQL 語法字串，一句或兩句就可以完成的動作，\n卻因 ORM 套件或 SQL 語法字串沒寫好造成在取得特定資料時得重復下差不多的 SQL 語法字串，\n造成效能問題。\n\n以下為 N+1 範例\n\ncats=loadcats();foreach(\n\ncats as $cat) {\ncatshats=loadhatsforcat(\n\ncat);\n// …\n}\n\n假設 load_cats 的實作是以下 query\n\nSELECT * FROM cat WHERE …\n\n而 load_hats_for_cat($cat) 則是\n\nSELECT * FROM hat WHERE catID = …\n\n那麼結果就會是執行 N+1 query\n\nSELECT * FROM cat WHERE …\nSELECT * FROM hat WHERE catID = 1\nSELECT * FROM hat WHERE catID = 2\nSELECT * FROM hat WHERE catID = 3\nSELECT * FROM hat WHERE catID = 4\nSELECT * FROM hat WHERE catID = 5\n…\n\n假設 cat 有5隻，第1次下 load_cats(); 取得5隻 cat 的資料，\n然後再用 foreach 迴圈5次下 load_hats_for_cat($cat); ，\n那麼結果就是 5+1 (N+1) ，如果資料少的時候，對於效能的影響可能感受不太出來，\n但是一但資料多的時候，就會嚴重拖累效能，因此比較好的方式是，\n先將所有資料都從資料庫取出來，再用迴圈去重組資料格式。\n\n例如\n\n$cats = load_cats();\nhats=loadallhatsforthesecats(\n\ncats);\nforeach ($cats as $cat) {\n$cats_hats = hats[\n\ncat->getID()];\n}\n\n轉成 query 的話就是\n\nSELECT * FROM cat WHERE …\nSELECT * FROM hat WHERE catID IN (1, 2, 3, 4, 5, …)\n\n透過這樣的方式，無論資料有多少，都只要下兩個 query 就可以取得所有資料，從而避免了效能問題。\n",
      "createdAt": 1608746453293
    },
    {
      "id": 19,
      "userId": 1,
      "title": "week19",
      "body": "期末專案規劃\n \n黑皮驊官網-User Story\n \n身份:\n\n    使用者\n    管理員\n\n \n前台-\n \n首頁:\n\n    身為一個使用者，希望能在首頁看到招牌美食，這樣我就快速決定要不要吃\n    身為一個使用者，希望首頁能夠查看店裡是否有空位，這樣我才能決定要不要去現場\n    身為一個使用者，希望能夠在首頁透過 Uber eats 訂餐，這樣我就能夠不出門吃到好吃的餐點\n    身為一個使用者，希望能夠在首頁透過臉書粉專訊息按鈕聯絡小編，這樣我就可以馬上獲得解答\n    身為一個使用者，希望能夠在首頁按一鍵撥話按鈕，這樣我就可以在手機上快速透過電話訂餐\n    身為一個使用者，希望能夠有公告欄，這樣我就可以知道餐廳什麼時候公休，或是價格調整等等\n\n \n常見問題頁面:\n\n    身為一個使用者，希望能夠在問題頁面知道，滷肉飯+1、+2、+3是什麼意思，這樣我才能知道這些餐點有何差別\n    身為一個使用者，希望能在問題頁面知道外送限制，這樣我才可以決定，是否訂餐\n\n \n菜單頁面:\n\n    身為一個使用者，希望能在菜單頁面看到所有餐點，這樣我才可以快速掌握所有菜色\n    身為一個使用者，希望能夠在菜單頁面把我想買的餐點加入購物車，這樣我就可以快速結帳\n\n \n購物車頁面\n\n    身為一個使用者，希望能在購物車頁面得知總金額，這樣我就可以知道我花了多少錢\n    身為一個使用者，希望能夠直接透過線上付款結帳，這樣我就不用拿錢包找錢\n\n \n註冊頁面\n\n    身為一個使用者，希望能夠註冊帳號，以便追蹤訂單\n\n \n後台-\n \n訂單管理:\n\n    身為一個管理員，希望能看到訂單詳細訊息，這樣我才可以快速掌握目前下單情況\n    身為一個管理員，希望能夠取消訂單，這樣當訂購人有問題時，可以快速取消，進行其它處理\n    身為一個管理員，希望能夠編輯訂單，這樣當訂購人需要更改時，我就可以即時更改訂單，符合訂購人需求\n\n \n常見問題管理:\n\n    身為一個管理員，希望能夠新增常見問題，我就可以視需求隨時新增\n    身為一個管理員，希望能夠編輯更新常見問題，這樣我就可以把內容改的更易懂\n    身為一個管理員，希望能夠刪除常見問題，這樣就可以把不要的常見問題刪除\n    身為一個管理員，希望能夠看見目前常見問題列表，這樣我才可以知道目前有什麼常見問題\n\n \n餐點管理:\n\n    身為一個管理員，希望能夠看見目前所有的餐點列表，這樣我才可以快速掌握目前的餐點\n    身為一個管理員，希望能夠新增餐點，這樣有新餐點時就可以隨時上架\n    身為一個管理員，希望能夠刪除餐點，這樣就可以把不好賣的餐點去除\n    身為一個管理員，希望能夠編輯餐點，這樣我就可以更改餐點圖片、價格及數量\n\n \n使用者管理:\n\n    身為一個管理員，希望能夠列出所有使用者列表，以方便我管理\n    身為一個管理員，希望能夠搜尋使用者，這樣就可以快速取得使用者資訊\n",
      "createdAt": 1608746453293
    },
    {
      "id": 20,
      "userId": 1,
      "title": "week20",
      "body": "十六到二十週心得\n \n十六週心得\n\n這一週學到了 JavaScript 是如何初始化變數、 函式、物件導向以及 event loop 等等，\n\n看完影片加上做完作業之後，整個覺得超充實的!，尤其是理解了 JavaScript 初始化的過程，\n讓我能夠更容易閱讀程式碼並找出有錯誤的地方；而 event loop 的部份則是讓我了解到 JS 在瀏覽器是如何透過 webAPI 處理事件，\n及 event queue 是如何運作的。\n\n總之，是一堂非常充實的課，如過要再深一點研究的話，可以看\nYou-Dont-Know-JS-第一版\nYou-Dont-Know-JS-第二版\n或是\n阮一峰的JavaScript 教程\n阮一峰的JavaScript ES6 教程\n\n以上只有看了一點，是我後續要讀的清單，想要對底層運作更熟悉!!\n \n十七週心得\n\n本週學習如何運用 Expres 、ORM 套件打造網頁程式並且部署到 heroku。\n\n最令我覺得困難的部份是 ORM 的使用，由於不熟悉，所以在建立 model 時，不知道 model 檔案 及 migration 檔案之間的關連，\n所以會導致在改 table columns 時，會發生 model 跟 migration 的 table 資料不一致，造成錯誤，後來才知道，\n如果要對已經 migrating 過的 table 欄位做變動，那就應該要建立一個新的 migration 檔案，並在其中寫入要變動的語法，\n再進行 db:migrate，讓本地跟 db 資料同步，慢慢熟了之後，就覺得很方便，不用再寫 SQL 語法真的很爽Q\n\n對了，還有就是，由於部落格當初做的比較完整一點，所以改寫成 express 版本花的時間較久，哈哈。\n \n十八週心得\n\n這一週延續17週學到的東西，用寫作業的方式練習熟悉 express 跟 sequelize，這一週作業基本上沒什麼難度，\n所以很快就做完了，在這一週裡更熟悉如何使用 sequelize 以及從 Huli 老師那裡學到了在撈例如商品資料時，\n如果量太大，不適合一次撈出來再過濾自己要的資料，而是一筆一筆去撈。\n\n另外就是學到如何用 Nginx 去代理 Node apps，讓我成功的用 Docker + nginx + php + node 部署到 AWS 主機上，\n另外也感恩 Huli 老師解答了我關於 Nginx 代理到同 ip 但不同網址的設定問題。\n \n十九週心得\n\n本週學到了一些未來工作可能會運用到的工具及流程，例如 agile 敏捷式開發、Scrum 、產品文件撰寫以及 User story 等等\n\n了解到 Scrum 是 agile 敏捷式開發 的一種，透過兩到四週的 Sprint 為一個週期進行開發與檢討，角色有三種，\n產品負責人、Scrum 監督以及開發團隊，流程則為，開規劃會議、寫 User story、\n根據 User story 寫下實作細節 Tasks、每日立會進度說明及調整進度以及回顧會議。\n \n二十週心得\n\n本週基本上我都在玩 18週的超級挑戰題，購物車+串結帳金流，最後成功的建好購物車頁面及串好金流，\n雖然購物車頁面目前還不支援 RWD 並且因時間的因素，付款完後的訂單查詢功能沒有做完整，\n但終究還是完成超挑題的要求，串金流了開心XD~~剩下的細節可以留待之後有時間再完善吧…現在就先這樣了Q\n\n放上購物車頁面\n \n網站優化成果\n\n優化後網址\n\nhttps://chang-ching-chung.github.io/lazy-hackathon/\n\nWebPageTest 報告網址\n\nGoogle PageSpeed Insights\n\n行動版分數截圖:\n\n電腦版分數截圖\n\nWebPageTest\n\n截圖:\n \n你做了哪些優化？\n\n    壓縮圖片，一開始是用 gulp-imagemin 去壓縮圖片，但發現還是太大\n    ，最後換成用 imagemin + imagemin-webp 將圖片全轉成 webp ，\n    轉換完之後，最大檔案是 415 KB 最小則是 1KB。\n\n    把沒用到的 CSS 刪掉及壓縮，使用的套件為 gulp-purifycss。\n\n    把 Jquery, bootstrap, index 等 JS 檔壓縮，使用到的是線上壓縮網站，JavaScript Minifier\n\n    刪掉 HTML 裡的註解及沒用到的 CDN 連結，並且壓縮 HTML ，使用的是線上 HTML 壓縮網站HTML minifier\n\n    將 CDN 通通加上 defer，讓瀏覽器在 DOM 都解析完再載入 CDN。\n\n    使用 Lazy loading 套件，vanilla-lazyload，延遲載入圖片，只有當畫面滾動到有圖片的位置時才載入，使資源可以集中在第一畫面的載入。\n\n通過這樣的優化過程，讓我了解到我的方向沒錯，圖片是最吃資源的，通常只要圖片壓得夠小，就可以大幅減少載入時間，\n因此第一時間想到的就是，壓縮圖片、壓縮 JS 及刪除及壓縮 CSS ，這幾個方向之中，\n最有用的就是壓縮圖片從 png 轉成 webp 以及 Lazy loading，這兩個做完其實就已經優化的差不多了，\n剩下的 CSS 及 JS 壓縮只是錦上添化而已，因為並沒有完全的把無用的 JS 程式碼刪掉QQ\n\n在這裡要跪拜一下大神 yakim-shu，優化報告解說得超級詳細，簡直就是優化聖經了QQ，希望有認識的機會，好好的學一下更多關於網頁優化的技術。",
      "createdAt": 1608746453293
    },
    {
      "id": 21,
      "userId": 1,
      "title": "week21",
      "body": "為什麼我們需要 React？可以不用嗎？\n\n     \n\n狀態管理，所有的元件都與它們自己的狀態綁一起，我們不用直接操作 DOM ，只要透過改變狀態，React 就會自動更新重新渲染畫面，而且速度可能比我們直接操作 DOM 還快。\n\n邏輯跟元件綁一起，每個元件有各自相對應的處理邏輯，而不是像一般使用JavaScript 操作 DOM 那樣，要針對每個要操作的 DOM 設置事件監聽以及邏輯，造成東一個函式、西一個函式的情況。\n\n不用操作 DOM，只需要寫好 Components 的狀態及行為，剩下的 React 會透過虛擬 DOM 幫我們處理渲染及事件監聽等等行為。\n\n     \n\n當然可以不用，如果是小型專案，沒有涉及太多資料狀態的話，直接透過 JavaScript 操作 DOM 反而會比較快呢！當然要用也是可以，沒有一定，不過根據需求選擇適合的工具會比較好，例如，網頁裡面有許多會根據資料狀態更新畫面的元素的時候，就是使用 React 的好時機。\n \nReact 的思考模式跟以前的思考模式有什麼不一樣？\n\nReact 是以元件為單位來思考，要構建元件前，先了解該元件會有什麼資料狀態，再根據該資料狀態建立元件，最後再幫元件加入一些操作邏輯，當元件執行那些操作邏輯後，隨著資料的改變去更新元件的狀態並渲染畫面，這就是「 React」的核心精神，對資料的改變 React。\n\n而以前的思考模式則是直接操縱 DOM 取資料或放資料，沒有狀態的這一個概念，要更新畫面必須透過各個事件監聽器及函式的互相配合，也就是說，DOM 之間沒有直接的關連，導致資料狀態不好追蹤掌控。\n \nstate 跟 props 的差別在哪裡？\n\nState 是元件的相關資料，元件透過 State 的變動更新畫面，也就是說， State 就是元件的核心，\n而要更新 State 的話，只能透過 setState 的方式去更新，直接對 State 更新的話， React 將無法追蹤 State 的變動。\n\nProps 是元件的屬性，所有從父元件傳進來的值都會放進 Props 這個物件，當然，我們也可以設定 Props 的預設值，而 Props 是不可變的。\n\nReact 是 One way data flow 傳資料的，也就是說，只有一條路，從上到下，從父元件到子元件，將\nState 傳到子元件，存成 Props 的一部份，經過一番資料處理後，再透過從父元件傳下來的 setState\n將父元件的 State 更新成資料處理過後的 State 達到對父元件 State 的處理及更新。",
      "createdAt": 1608746453293
    },
    {
      "id": 22,
      "userId": 1,
      "title": "week22",
      "body": "\n請列出 React 內建的所有 hook，並大概講解功能是什麼\n\n    useState: 用來處理元件內跟元件相關的反應式資料，這個 hook 會回傳一個狀態值以及一個用來更新壯態的函式。\n\n    useEffect: 主要用來監聽某個值，並且隨者值的改變，執行函式，可用在\"登入\"、\"畫面渲染後的抓取遠端資料\"或\"畫面渲染前的資料處理\"等等。\n    這個方法需要帶兩個參數，第一個是函式，第二個是包含要監聽資料的陣列，如果給的函式裡面帶一個回傳函式，\n    那麼回傳函式將會在元件從畫面被移除的時候呼叫。\n\n    useContext: 用來將狀態分享給所有子元件用的，使用這個 hook ，我們將不用一個一個的從上層把狀態值傳給子元件。呼叫 userContext 的元件，當 context 的值改變時，就會重新渲染。\n\n    useReducer: 跟 useState 一樣，會給予一個狀態值以及一個更新狀態的函式，不同的是，\n    一開始要傳進去 useReducer 的會是一個函式以及初始值，\n    函式接受兩個參數，一個是前狀態值，一個是要更新的狀態值，而初始值則是會傳進去函式裡面處理的值，\n    useReducer 跟 陣列的 reduce 用法差不多。\n\n    useCallback: 主要用來性能優化用的， useCallback 接受兩個參數，一個是要被記住的 callbackk 函式，一個是包含了要監聽的值的陣列，被記住的函式，只有在被監聽的值改變了之後才會被重新建立。\n\n    useMemo: 跟 useCallback 很像，但 useMemo 是用來記住值的。這個函式接受兩個參數，第一個為函式，第二個則是要監聽的值，傳進去的函式會回傳一個值，只有當監聽的值改變時，才會執行函式。\n\n    useRef: 用來儲存一個值，該值在元件的生命週期內持續存在，但在值發生變化時不會重新渲染，值存在 .current 中，可以跟 ref 一起使用來保存 DOM 元素。\n\n    useImperativeHandle: 用來客製化要傳什麼值給父元件，當使用 ref 時，要搭配 forwardRef 使用。\n\n    useLayoutEffect: 作用跟 useEffect 完全相同，唯一不同的地方是，什麼時候執行， useEffect 是在 DOM 被更新後執行，而 useLayoutEffect 則是在 DOM 更新之前執行，通常是用在當 UI 有閃爍之的時候。\n\n    useDebugValue: 用來在 React DevTools 中顯示自定義 hook 的標籤。\n\n \n請列出 class component 的所有 lifecycle 的 method，並大概解釋觸發的時機點\n \nMounting\n\n    constructor: 一個 React 的 constructor 會在其被 mount 之前被呼叫。\n    static getDerivedStateFromProps: 會在元件被 render 前被呼叫，不管是第一次 mount 或是更新時。\n    render: 當檢查完 thus.props 以及 this.state 中的變化之後，將元素顯示在瀏覽器上。\n    componentDidMount: 當一個元件被加入至 DOM tree 之中， componentDidMount 會馬上被呼叫。\n\n \nupdating\n\n    static getDerivedStateFromProps: 會在元件被 render 前被呼叫，不管是第一次 mount 或是更新時。\n    shouldComponentUpdate: 當狀態被更新之後，可以加入 shouldComponentUpdate 來讓元件不重新渲染。\n    render: 當檢查完 thus.props 以及 this.state 中的變化之後，將元素顯示在瀏覽器上。\n    getSnapshotBeforeUpdate: 會在 render 的輸出送給 DOM 時被呼叫，在 DOM 改變之前做一些操作，例如滾動軸的位置，這個方法回傳的值會當作一個參數傳給 componentDidUpdate。\n    componentDidUpdate: 在元件更新之後觸發，此方法不會在第一次 render 時被呼叫。\n\n \nUnmounting\n\n    componentWillUnmont: 會在元件被移除之後馬上被呼叫，可以在這個方法內進行清理事件監聽或是計時器等，要注意的是，不應該在 componentWillUnmount 內呼叫 setState ，因為這個元件永遠不會再重新 render。\n\n \n請問 class component 與 function component 的差別是什麼？\n\n    Syntax: class component 是一個繼承 React.Component 的 class，有者會回傳 JAX 的 render 方法，而 functional component 則是一個回傳 JSX 語法的 function。\n    Passing props: 傳給 functional component 的參數會被放到叫 props 的 object ，可以用解構的方式或是 props.someValue 的方式取的傳進來的參數，\n    而 class component 則需要加上 this 指向呼叫 render 方法的 class ，例如: this.props.someValue，這邊要注意的是，只有 functional component 會記住傳進來的值而不會隨者重新 render 而抓到更新後的值，詳見How Are Function Components Different from Classes?。\n    Handling state: 在 React 16.8 以後的版本， functional component 加入了 hook 的功能，使 functional component 可以使用 useState 變成一個 stateful functional component ，\n    useState 可以傳入任何值當初始值，然後回傳給我們兩個變數，一個是 state 一個是 用來更新 state 的 function，而在 class component 裡，要使用 state ，\n    我們需要加上 constructor 以及呼叫 super 否則的話，所有的 state 變數都會是 undefined，而在 class component 裡，state 是一個 object，裡面存放我們需要的資料，\n    更新 state 的方式則是呼叫 this.setState，然後傳入一個裡面帶有要更新的值的物件。\n    Lifecycle Methods:\n    4.1 On Mounting (componentDidMount): 在 class component 裡，componentDidMount 會在元件第一次渲染後被呼叫，而在 functional component 裡，\n    則是使用 useEffect 來達到跟 componentDidMount 一樣的效果，例如: useEffect 第二個參數傳一個空陣列的話，useEffect 就只會在第一次渲染後被呼叫。\n    4.2 On Unmounting (componentWillUnmount): 在 class component componentWillUnmount 會在元件要被移除之前被呼叫，而在 functional component 裡，\n    則是只要在 useEffect 的第一個函式參數裡回傳另一個函式，該函式就會在元件要被移除之前被呼叫，達成跟componentWillUnmount 一樣的效果。\n\n \nuncontrolled 跟 controlled component 差在哪邊？要用的時候通常都是如何使用？\n\n    uncontrolled 跟 controlled component 差異\n    1.1 controlled component: 受控制的 component 透過 props 取得目前的值，\n    然後透過 onChange 或 onClick 等事件監聽受控制的 component 的輸入，\n    一但監聽事件發生，就會呼叫 callback function 執行 setState 更新 state ，\n    然後受控制的 component，會接收到最新的值。\n\n    1.2 uncontrolled component: 跟傳統的 HTML 一樣，我們輸入的值會存在它自己內部的 state ，要取得值的方法則是透過 DOM 操作\n    ，使用 ref 或是 document.selector 去選取該元素取值，而不是透過 React 操控該元件的值。\n\n    如果是很簡單的 UI ，不涉及其它 component 的話，一次性的提交或是做資料驗證的時候是可以使用 uncontrolled component\n    的，但在大部份情況下，做好還是使用 controlled component。\n\n資料來源: controlled-vs-uncontrolled-inputs-react\n",
      "createdAt": 1608746453293
    },
    {
      "id": 23,
      "userId": 1,
      "title": "week23",
      "body": "\n為什麼我們需要 Redux？\n\n因為在 React 裡，我們要把 state 共享給子組件的方式只有將 state 作為 props 傳下去，要是這個組件元件很長，那麼我們就需要一層一層傳下去，像這樣:\n\n          主元件(state)\n            |\n            V\n        子元件 -- 子元件(props)\n            |\n            V\n子元件 -- 子元件 -- 子元件(props) // 真正要使用state 的子元件\n\n像上面示意圖這樣會變得很難維護，因此，就出現了 Redux。\nRedux 將 state 當做全域變數存放起來，我們的子元件要使用的時候只需要將 state 映射到子元件的 props 就可以了，再也不用一層一層的傳，難以維護，重複性高的 code 了。\n\n結論: Redux 讓我們將 state 提升到全域，使得所有組件可以共享這個 state ，直接把元件之間只能把 state 從上傳到下，導致組間之間無法交流資料的問題解決了。\n \nRedux 是什麼？可以簡介一下 Redux 的各個元件跟資料流嗎？\n\n    Redux 是一個狀態管理工具，透過這個工具，我們可以更有效的管理狀態，使得狀態的變化更有預測性，並且，Redux 透過一些限制，使得狀態只能透過 Redux 提供的 Api 來更改，避免了狀態在程式執行期間可能會受到非預期的更改的問題。\n    Redux 元件 & 資料流\n    2.1 Actions: Actions 是一個物件，物件裡面包含了 type 以及 payload ，應用程式會透過 Actions 傳遞資料到 store ，它們是 store 唯一的資料來源。\n    2.2 Reducer: Reducer 是用來計算並產生新的狀態的元件，使用方式就跟 Array.reduce 是一樣的，透過傳入先前的 state，跟一個 action，內部計算過後回傳新的 state。\n    2.3 Store: Store 是將 Reducer 以及 Actions 結合起來所產生的物件，Store 的功能有:\n        掌管應用程式狀態\n        藉由 getState 獲得 state\n        藉由 dispatch 更新 state\n        藉由 subscribe 註冊 listener\n        藉由 subscribe 回傳的 function 處理撤銷 listener。\n        要注意的是， Redux 應用程式裡只會有一個 store ，所以如果要把資料處理邏輯拆分時，會使用 combineReducers 將不同的 reducer 結合在一起，產生一個 store。\n        2.4 資料流: Redux 的架構為嚴格的單向資料流，也就是說，應用程式中的全部資料全都遵照一樣的生命週期模式，這使得應用程式的邏輯更容易預測與了解。Redux 的資料生命週期有4個步驟:\n        呼叫 store.dispatch(action)\n        Redux store 呼叫你傳給它的 reducer function\n        Rotot reducer 把多個 reducer 的 output 合併成一個單一的 state tree\n        Redux store 儲存 Root reducer 回傳的完整 state tree\n\n \n該怎麼把 React 跟 Redux 串起來？\n\n透過 Redux 提供的 connect API。\nconnect() 透過 mapStateToProps 將儲存在 store 的 state 映射到 React 的元件裡，這樣我們就可以透過 props 拿到 store 的資料，而 mapDispatchToProps ，則是會提供 dispatch 函式讓我們自定義一些方法，然後透過 dispatch 將 action 傳給 reducer。\n",
      "createdAt": 1608746453293
    },
    {
      "id": 24,
      "userId": 1,
      "title": "week24",
      "body": "\nRedux middleware 是什麼？\n\nRedux middleware 如名稱所說，是個中介軟體，介於 dispatch 跟 reducer 中間，用來做非同步處理或是將 action 跟其它資料一起加工，再送給 reducer，reducer 再把舊的 state 更新並送回給使用者。\n\n除了 Redux 提供的 thunk middleware 之外，我們也可以客製化自己的 middleware 並利用 applyMiddleware 加入到 redux 裡面使用，值得注意的是，一但應用了 middleware 那麼每次發 action 的時候，都一定會經過 middleware 的處理，一般來說最常使用的是 thunk middleware，經過 thunk 的函式都會被提供 getState 與 dispatch ，來讓我們可以回傳一個帶有 dispatch 的函式，再透過 dispatch 去將 fetch 遠端回來的資料送給 reducer。\n\n使用 thunk middleware 必須要將函式寫成\n\n \n\n \n\nconst example = (extraArgs) => (dispatch) => { //other code..... return fetch(\"/getUser\").then(res => { dispatch({type:\"GET_USER_NAME\", payload: res.userName}) }) }\n\n透過上面的函式，我們將可以在非同步 fetch 中使用 dispatch 將 fetch 得到的資料傳進 reducer 更新。\n \nCSR 跟 SSR 差在哪邊？為什麼我們需要 SSR？\n\n    CSR 跟 SSR 差在哪邊？\n    CSR: Client side rendering 客戶端渲染\n    SSR: Server side rendering 伺服器端渲染\n    CSR 顧名思義，畫面是當客戶端接收到伺服器傳來的 html 檔案之後，啟動裡面崁入的 JavaScript 檔案再將畫面渲染到 html 裡面。使用 CSR 技術的網站，使用 DevTool 檢查源始碼時，會發現裡面是空的。\n    SSR 則是伺服器端直接傳一份已經渲染好了的 html 檔案給客戶端。使用 SSR 技術的網站，使用 DevTool 檢查源始碼時，會發現裡面充滿了 html 元素，跟你在畫面上看到的一模一樣。\n\n    為什麼我們需要 SSR？\n    因為 SEO ，使用 SSR 可以讓 Google 或是其它搜尋引擎等更好且正確的爬到\n    關於你網站的資訊，因為它們的機器人可以直接讀取渲染好的整份 html 檔案，而不像 CSR 是空白的，搜尋引擎機器人或爬蟲沒辦法在空白的頁面上獲得跟網站相關的資訊，就會使得網站的能見度變低。\n\n \nReact 提供了哪些原生的方法讓你實作 SSR？\n\nReact DOM 提共了兩個方式實作 SSR\n\n    ReactDOMServer.renderToString(): 傳入 element 進去，會回傳 HTML 字串，並當作 Response 回傳給客戶並顯示。\n    ReactDOMServer.renderToStaticMarkup(): 功能跟renderToString差不多，一樣是回傳HTML 字串，並當作 Response 回傳給客戶並顯示，但裡面不會有 React DOM 屬性。\n\n這兩種的差別在於，renderToStaticMarkup 不會產生 React 內部使用的 DOM 屬性，例如:data-reactroot，而如果想讓客戶端跟 Markup 互動的話，則須使用renderToString() 配上hydrate() 來將 event listener 附加到 component 上。\n \n承上，除了原生的方法，有哪些現成的框架或是工具提供了 SSR 的解決方案？至少寫出兩種\n\n    Prerender: 安裝完後會在我們自己的 server 上去偵測每個 request ，一但發現是搜尋引擎機器人發出的 request ，就會發送一個 request 去 Prerender.io 取得幫你 cache 的，已渲染好的靜態網頁，然後回傳給客戶端。\n    Next js: 提供了 Pre-rendering 的功能，我們能夠直接建立 page 並在 build 的階段就產生渲染完的靜態頁面並回傳給客戶端。\n\n \n",
      "createdAt": 1608746453293
    }
  ],
  "users": [
    {
      "id": 1,
      "nickname": "我是 user01",
      "username": "user01",
      "password": "john"
    },
    {
      "id": 2,
      "nickname": "管理員",
      "username": "admin",
      "password": "john"
    }
  ],
  "profile": {
    "name": "John's blog JSON Server API"
  }
}